<!DOCTYPE html>
<html>
	<head>
		<title>Badminton Demo</title>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r82/three.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js'></script>
		<script src='controls/OrbitControls.js'></script>
		<script src='controls/DeviceOrientationControls.js'></script>
		<script src='build/three.badminton.min.js'></script>
		<link href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.6/css/bootstrap.min.css' rel='stylesheet'/>
		<script id='robotBody_vertexShader' type='x-shader/x-vertex'>
			varying vec2 vUv;
			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				vUv = uv;
			}
		</script>
		<script id='robotBody_fragmentShader' type='x-shader/x-fragment'>
			uniform vec3 topColor;
			uniform vec3 bottomColor;
			varying vec2 vUv;
			void main() {
				if (vUv.y > 0.5)
					gl_FragColor = vec4(topColor, 1.0);
				else
					gl_FragColor = vec4(bottomColor, 1.0);
			}
		</script>
		<script id='healthPercent_vertexShader' type='x-shader/x-vertex'>
			varying vec2 vUv;
			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				vUv = uv;
			}
		</script>
		<script id='healthPercent_fragmentShader' type='x-shader/x-fragment'>
			uniform float healthPercent;
			varying vec2 vUv;
			void main() {
				if (vUv.x < healthPercent / 100.0)
					gl_FragColor = vec4(1, 0, 0, 0.6);
				else
					gl_FragColor = vec4(1, 1, 1, 0.6);
			}
		</script>
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
			#stats {
				position: fixed;
				top: 0;
				left: 0;
			}
			.full-screen {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
			}
			.overlay {
				opacity: 0.5;
				background: black;
				pointer-events: none;
			}
			.center-screen {
				position: fixed;
				top: 30%;
				left: 30%;
				right: 30%;
			}
			#start {
				color: yellow;
			}
			#countdown .counter {
				font-size: 60pt;
				color: yellow;
			}
		</style>
	</head>
	<body>
		<div id='start' class='heading' onclick='start()'>
			<div class='full-screen overlay'></div>
			<div class='center-screen text-center'>
				<h1>Badminton Game</h1>
				<h2>Click to Start</h2>
			</div>
		</div>
		<div id='countdown' class='heading' style='display: none;'>
			<div class='full-screen overlay'></div>
			<div class='center-screen text-center'>
				<span class='counter'></span>
			</div>
		</div>
		<div id='pause' class='heading' style='display: none;'>
			<div class='full-screen overlay'></div>
			<div class='center-screen panel panel-primary'>
				<div class='panel-heading'>Paused</div>
				<div class='panel-body text-center'>
					<a href='javascript:resume()' class='btn btn-default btn-block btn-lg'>Resume</a>
					<a href='javascript:start()' class='btn btn-default btn-block btn-lg'>New Game</a>
					<a href='javascript:replay()' class='btn btn-default btn-block btn-lg btn-replay' style='display: none;'>Replay</a>
				</div>
			</div>
		</div>
		<script>
			var camera, scene, renderer, controls, stats, clock;
			var shuttle, court, game, scoreboard, record;
			var robot1, robot2;
			var targetPoint1, targetPoint2;
			var mouse, raycaster;
			var animated = false, paused = false, isOpening = true;
			var countdown = false, counter = 0, countEnding = null;
			var delay = 1, replayIndex = -3;
			var touchable, intersects, touchableTip;
			var allRecordData;

			init();
			animate();

			function init() {

				scene = createScene();

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 20000);
				camera.position.set(-800, 300, 0);
				scene.add(camera);
				
				clock = new THREE.Clock();
				
				shuttle = createShuttlecock();
				scene.add(shuttle);
				
				court = createCourt();
				scene.add(court);
				
				var courtArea = court.getArea('All');
				touchable = new THREE.Mesh(
					new THREE.PlaneGeometry(courtArea.max.x - courtArea.min.x, courtArea.max.y - courtArea.min.y),
					new THREE.MeshBasicMaterial({ visible: false }));
				court.add(touchable);
				
				mouse = new THREE.Vector2();
				raycaster = new THREE.Raycaster();
				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);
				
				robot1 = createRobot('white', 'blue', shuttle, court);
				robot1.rotation.y = Math.PI / 2;
				robot1.onAfterImpact = function () {
					if (record.playing)
						record.next();
					else {
						record.record();
						
						robot2.impactType = getRandomImpactType();
						
						var randomPosition = getRandomPosition(robot1.responsibleArea, 0.8);
						robot2.targetPosition.copy(randomPosition);
						targetPoint2.position.copy(randomPosition);
					}
					
					this.setResponsibleArea(court.localToTarget(court.getAreaSingleA(), this.parent));
				};
				scene.add(robot1);
				
				robot2 = createRobot(0xff0000, 0x800000, shuttle, court);
				robot2.rotation.y = -Math.PI / 2;
				robot2.onAfterImpact = function () {
					if (record.playing)
						record.next();
					else
						record.record();
					this.setResponsibleArea(court.localToTarget(court.getAreaSingleB(), this.parent));
						
					scene.remove(touchableTip);
					touchableTip = createTouchableTip();
					scene.add(touchableTip);
				};
				robot2.onBeforeUpdate = function() {
					if(this.impactType === 'smash' || this.impactType === 'top') {
						var shuttlePosition = this.shuttlecock.localToTarget(new THREE.Vector3(0, 0, 0), court);
						if (shuttlePosition.y < 185 && shuttlePosition.x > 0)
							this.impactType = 'right';
					}
				};
				scene.add(robot2);
				
				targetPoint1 = new THREE.Badminton.TargetPoint(20, 5, 
					new THREE.MeshNormalMaterial(), 
					new THREE.MeshNormalMaterial());
				scene.add(targetPoint1);
				
				targetPoint2 = new THREE.Badminton.TargetPoint(20, 5, 
					new THREE.MeshNormalMaterial(), 
					new THREE.MeshNormalMaterial());
				scene.add(targetPoint2);
				
				scoreboard = createScoreboard();
				scoreboard.rotation.y = -Math.PI / 4;
				scoreboard.position.z = -400;
				scene.add(scoreboard);
				
				game = new THREE.Badminton.Game('B');
				game.onScoreChange = function () {
					
					if (isOpening)
						return startBackgroundReplay();
					
					if (record.playing)
						return;
					
					if (this.lastWinner === 'A')
						scoreboard.setAction(0, this.scoreA, 'next');
					else
						scoreboard.setAction(3, this.scoreB, 'next');
					
					$('#pause .btn-replay').show();
					startCountdown(function () {
						$('#pause .btn-replay').hide();
						next();
						startCountdown(function () {
							animated = true;
						}, 3);
					}, 3, false);
				};
				
				record = new THREE.Badminton.Record(shuttle, robot1, robot2);
				
				next();
				
				$.getJSON('recordData.json', function (json) {
					allRecordData = json;
					if (!$('#start').is(':hidden'))
						startBackgroundReplay();
				});
				
				createGUI(robot1, robot2, game, record);
				
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				
				stats = new Stats();
				stats.domElement.setAttribute('id', 'stats');
				
				document.body.appendChild(stats.domElement);
				document.body.appendChild(renderer.domElement);
				document.addEventListener('keyup', onDocumentKeyUp, false);
				document.addEventListener('keypress', onDocumentKeyPress, false);
				document.addEventListener('mouseup', onDocumentMouseUp, false);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				window.addEventListener('resize', onWindowResize, false);
			}
			
			function onDocumentKeyUp(event) {
				
				if (event.keyCode === 27) {
					
					if (isOpening)
						return;
					
					paused = !paused;
				}
			}

			function onDocumentKeyPress(event) {
				
				if (isOpening || paused)
					return;
				
				switch (event.key) {
					case 'w':
					case 'W':
						robot1.impactType = 'top';
						break;
					case 's':
					case 'S':
						robot1.impactType = 'smash';
						break;
					case 'a':
					case 'A':
						robot1.impactType = 'left';
						break;
					case 'd':
					case 'D':
						robot1.impactType = 'right';
						break;
				}
			}
			
			function createGUI(robot1, robot2, game, record) {
				
				var gui = new dat.GUI();
				gui.close();
				
				gui.add(this, 'animated').listen();
				gui.add(this, 'next').name('Next');
				
				gui.add(game, 'nthScore').listen();
				gui.add(game, 'scoreA').listen();
				gui.add(game, 'scoreB').listen();
				
				gui.add(this, 'replay').name('Replay');
				gui.add(record, 'playing').name('replaying').listen();
				
				gui.add(this, 'delay', 1, 30);
				gui.add(this, 'replayIndex', -10, 10);
				
				var gcontrols = {
					control: 'orbit',
				};
				gui.add(gcontrols, 'control', ['orbit', 'deviceOrientation']).onChange(onControlChange);
				
				function onControlChange(value) {
					controls.dispose();
					if (value === 'orbit') {
						controls = new THREE.OrbitControls(camera, renderer.domElement);
					} else if (value === 'deviceOrientation') {
						controls = new THREE.DeviceOrientationControls(camera);
					}
				}
				
				addRobot(robot1, 'A (Player)');
				addRobot(robot2, 'B (Computer)');
				
				function addRobot(robot, name) {
					var f = gui.addFolder(name);
					f.add(robot, 'healthPercent', 0, 100).listen();
					f.add(robot, 'impactType', ['left', 'right', 'top', 'smash']).listen();
					f.open();
				}
			}
			
			function createScene() {
				
				var scene = new THREE.Scene();
				
				var textureLoader = new THREE.TextureLoader();
				var skybox = new THREE.Mesh(
					new THREE.BoxGeometry(10000, 10000, 10000, 1, 1, 1),
					new THREE.MultiMaterial([
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox1.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox2.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox3.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox4.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox5.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox6.png'), side: THREE.BackSide }),
					])
				);
				scene.add(skybox);
				
				var ground = new THREE.Mesh(
					new THREE.CylinderGeometry(1500, 400, 300, 64),
					new THREE.MeshLambertMaterial({ color: 0x082908 }));
				ground.position.y = -150.1;
				scene.add(ground);
				
				var light = new THREE.SpotLight(0xffffff, 60, 950, 1, 0.6, 2);
				light.position.y = 700;
				scene.add(light);
				
				return scene;
			}
			
			function createCourt() {
				
				var shortLine = 198;
				var longLineSingle = 670;
				var longLineDouble = 594;
				var sidelineSingle = 259;
				var sidelineDouble = 305;
				var lineWidth = 10;
				
				var netWidth = sidelineDouble * 2;
				var netHeight = 110;
				var netOuterTube = 5
				var netInnerTube = 2
				var netWidthSegments = netWidth / 10;
				var netHeightSegments = netHeight / 10;
				
				var postRadius = 5;
				var postHeight = 155;
				
				var court = new THREE.Badminton.Court(
					new THREE.Badminton.CourtGeometry(shortLine, longLineSingle, longLineDouble, sidelineSingle, sidelineDouble, lineWidth),
					new THREE.MeshBasicMaterial({ color: 'white', side: THREE.DoubleSide }));
				court.rotation.x = -Math.PI / 2;
				
				var net = new THREE.Mesh(
					new THREE.Badminton.NetGeometry(netWidth, netHeight, netOuterTube, netInnerTube, netWidthSegments, netHeightSegments),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 0xdddddd }));
				
				var post = new THREE.Mesh(
					new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 16),
					new THREE.MeshBasicMaterial({ color: 'gray' }));
				
				var netGroup = new THREE.Badminton.NetGroup(net, post);
				netGroup.rotation.set(Math.PI / 2, -Math.PI / 2, 0);
				court.add(netGroup);
				
				court.netGroup = netGroup;
				court.postHeight = postHeight;
				
				return court;
			}
			
			function createShuttlecock() {
				
				var corkRadius = 2.5;
				var skirtRadius = 5;
				var beltHeight = 1;
				var skirtHeight = 6.5;
				var widthSegments = 16;
				var heightSegments = 8;
				var rachisRadius = 0.1;
				var rachisRatio = 3 / 7;
				var featherWidth = 1;
				var featherRatio = 7 / 3;
				var featherAngle = 0.1
				
				var corkMass = 0.005; // mass
				var skirtMass = 0.0001; // mass
				var airDensity = 0.0000011839; // mass * length^-3
				var gravity = new THREE.Vector3(0, -980, 0); // mass * length * time^-2
				
				var shuttlecock = new THREE.Badminton.Shuttlecock(
					new THREE.Badminton.ShuttlecockGeometry(corkRadius, skirtRadius, beltHeight, skirtHeight, widthSegments, heightSegments, rachisRadius, rachisRatio, featherWidth, featherRatio, featherAngle, corkMass / skirtMass
				), new THREE.MultiMaterial([
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'black' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'beige' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' })
				]), corkMass, skirtMass);
				
				shuttlecock.airDensity = airDensity;
				shuttlecock.gravity.copy(gravity);
				
				var impactAudio = new Audio('audios/impact.mp3');
				shuttlecock.onAfterImpact = function () {
					var distance = camera.localToTarget(new THREE.Vector3(0, 0, 0), this).length();
					var volume = Math.max(1 - distance / 2000, 0);
					if (volume > 0) {
						impactAudio.currentTime = 0;
						impactAudio.volume = volume;
						impactAudio.play();
					}
				};
				
				return shuttlecock;
			}
			
			function createRobot(topColor, bottomColor, shuttlecock, court) {
				
				var racketWidth = 30;
				var racketHeight = 50;
				var racketTube = 1;
				var racketLineWidth = 1;
				var racketWidthSegments = 6;
				var racketHeightSegments = 10;
				
				var bodyOuterRadius = 25;
				var bodyInnerRadius = 20;
				var bodyHeight = 100;
				
				var headRadius = 25;
				
				var racketMesh = new THREE.Mesh(
					new THREE.Badminton.RacketGeometry(racketWidth, racketHeight, racketTube, racketLineWidth, racketWidthSegments, racketHeightSegments),
					new THREE.MultiMaterial([
						new THREE.MeshLambertMaterial({ color: 'orange' }),
						new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					]));
				
				var bodyMesh = new THREE.Mesh(
					new THREE.Badminton.HyperbolaGeometry(bodyOuterRadius, bodyInnerRadius, bodyHeight, 16, 16),
					new THREE.MultiMaterial([
						new THREE.ShaderMaterial({
							uniforms: {
								topColor:    { value: new THREE.Color(topColor)    },
								bottomColor: { value: new THREE.Color(bottomColor) },
							},
							vertexShader: document.getElementById('robotBody_vertexShader').textContent,
							fragmentShader: document.getElementById('robotBody_fragmentShader').textContent,
						}),
						new THREE.MeshBasicMaterial({ color: topColor }),
						new THREE.MeshBasicMaterial({ color: bottomColor }),
					]));
				
				var headFrame = new THREE.Object3D();
				headFrame.position.y = bodyHeight / 2 + headRadius;
				bodyMesh.add(headFrame);
				
				var head = new THREE.Mesh(
					new THREE.SphereGeometry(headRadius, 32, 32, Math.PI * 2 / 3, Math.PI * 5 / 3), 
					new THREE.MeshBasicMaterial({ color: 0x220000, side: THREE.DoubleSide }));
				head.rotation.z = Math.PI / 2;
				headFrame.add(head);
				
				var width = headRadius * 4 / 3;
				var height = headRadius * 3 / 4;
				
				var scene = new THREE.Scene();
				var renderTarget = new THREE.WebGLRenderTarget(width, height);
				
				var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, -10, 10);
				scene.add(camera);
				
				var eyeRight = new THREE.Object3D();
				eyeRight.position.x = -width / 4;
				scene.add(eyeRight);
				
				var eyeLeft = eyeRight.clone();
				eyeLeft.position.x *= -1;
				scene.add(eyeLeft);
				
				var eyebrowRight = new THREE.Mesh(
					new THREE.PlaneGeometry(width / 3, 2),
					new THREE.MeshBasicMaterial({ color: 'white' }));
				eyebrowRight.position.set(0, height / 4, 5);
				eyeRight.add(eyebrowRight);
				
				var eyeballRight = new THREE.Mesh(
					new THREE.CircleGeometry(width / 12, 32),
					new THREE.MeshBasicMaterial({ color: 'white' }));
				eyeballRight.position.set(0, 0, 5);
				eyeRight.add(eyeballRight);
				
				var eyebrowLeft = eyebrowRight.clone();
				eyeLeft.add(eyebrowLeft);
				
				var eyeballLeft = eyeballRight.clone();
				eyeLeft.add(eyeballLeft);
				
				var blackMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
				
				var monitor = new THREE.Mesh(
					new THREE.BoxGeometry(width, height, 2),
					new THREE.MultiMaterial([
						blackMaterial,
						blackMaterial,
						blackMaterial,
						blackMaterial,
						new THREE.Badminton.PixelMaterial({
							map: renderTarget.texture,
							size: new THREE.Vector2(width, height),
							pixelSize: new THREE.Vector2(1, 1)}),
						blackMaterial,
					]));
				monitor.position.z = headRadius * 2 / 3;
				headFrame.add(monitor);
				
				var robot = new THREE.Badminton.Robot(bodyMesh, racketMesh);
				robot.monitor = monitor;
				monitor.eyebrowRight = eyebrowRight;
				monitor.eyebrowLeft = eyebrowLeft;
				monitor.eyeballRight = eyeballRight;
				monitor.eyeballLeft = eyeballLeft;
				monitor.eyeballScope = width / 12;
				monitor.renderTarget = renderTarget;
				monitor.camera = camera;
				monitor.scene = scene;
				
				robot.shuttlecock = shuttlecock;
				
				robot.netHeight = court.postHeight;
				robot.netHeightDelta = court.postHeight / 10;
				
				window.scene.add(robot.spriteHealthPercent = new THREE.Mesh(
					new THREE.PlaneGeometry(100, 20),
					new THREE.ShaderMaterial({
						transparent: true,
						uniforms: {
							healthPercent: { value: 100 },
						},
						vertexShader: document.getElementById('healthPercent_vertexShader').textContent,
						fragmentShader: document.getElementById('healthPercent_fragmentShader').textContent,
					})));
				
				return robot;
			}
			
			function updateEyes(robot) {
				var monitor = robot.monitor;
				if (robot.impactType === 'smash') {
					monitor.eyeballLeft.position.x = monitor.eyeballRight.position.x = 0;
					monitor.eyebrowLeft.rotation.z = Math.PI / 8;
					monitor.eyebrowRight.rotation.z = -Math.PI / 8;
				} else {
					var position = shuttle.localToTarget(new THREE.Vector3(0, 0, 0), robot);
					var angle = Math.atan(position.x / Math.max(position.z, 0)) || 0;
					monitor.eyeballLeft.position.x = monitor.eyeballRight.position.x = THREE.Math.clamp(angle / (Math.PI / 4), -1, 1) * monitor.eyeballScope;
					monitor.eyebrowLeft.rotation.z = 0;
					monitor.eyebrowRight.rotation.z = 0;
				}
			}
			
			function createScoreboard() {
				var scoreboard = new THREE.Badminton.Scoreboard(
					new THREE.Badminton.ScoreboardGeometry(200, 100, 50),
					new THREE.MeshLambertMaterial({
						color: 0x0066ff,
						side: THREE.DoubleSide,
					}));
				
				scoreboard.addCard(50, 80, new THREE.Vector2(-65, 10), { side: THREE.DoubleSide, numberColor: 'red' });
				scoreboard.addCard(25, 40, new THREE.Vector2(-17.5, 10), { side: THREE.DoubleSide, numberColor: 'red' });
				scoreboard.addCard(25, 40, new THREE.Vector2(17.5, 10), { side: THREE.DoubleSide, numberColor: 'black' });
				scoreboard.addCard(50, 80, new THREE.Vector2(65, 10), { side: THREE.DoubleSide, numberColor: 'black' });
				
				var ring = new THREE.Mesh(
					new THREE.TorusGeometry(12, 1, 16, 16),
					new THREE.MeshBasicMaterial({ color: 'black' }));
				ring.rotation.y = Math.PI / 2;
				scoreboard.addRings(ring, [-80, -65, -50, -17.5, 17.5, 50, 65, 80]);
				
				return scoreboard;
			}
			
			function createTouchableTip() {
				
				var length = 5;
				
				var box = robot2.parent.localToTarget(robot2.responsibleArea.clone(), scene);
				
				var size = box.getSize();
				var center = box.getCenter();
				
				var touchableTip = new THREE.Object3D();
				touchableTip.position.y = 1;
				
				var material = new THREE.MeshBasicMaterial({ color: 'blue', side: THREE.DoubleSide });
				
				var left = new THREE.Mesh(new THREE.PlaneGeometry(length, size.z), material);
				left.rotation.x = -Math.PI / 2;
				left.position.copy(center).add(new THREE.Vector3(-size.x / 2 + length / 2, 0, 0));
				touchableTip.add(left);
				
				var right = left.clone();
				right.position.copy(center).add(new THREE.Vector3(size.x / 2 - length / 2, 0, 0));
				touchableTip.add(right);
				
				var top = new THREE.Mesh(new THREE.PlaneGeometry(size.x, length), material);
				top.rotation.x = -Math.PI / 2;
				top.position.copy(center).add(new THREE.Vector3(0, 0, -size.z / 2 + length / 2));
				touchableTip.add(top);
				
				var bottom = top.clone();
				bottom.position.copy(center).add(new THREE.Vector3(0, 0, size.z / 2 - length / 2));
				touchableTip.add(bottom);
				
				return touchableTip;
			}
			
			function getIntersectedPoint() {
				if (intersects.length > 0) {
					var point = court.worldToLocal(intersects[0].point);
					var area = robot2.parent.localToTarget(robot2.responsibleArea.clone(), court);
					if (point.x >= area.min.x &&
						point.x <= area.max.x &&
						point.y >= area.min.y &&
						point.y <= area.max.y) return point.setZ(0);
				}
				return null;
			}
			
			function onDocumentMouseDown(event) {
				
				onDocumentMouseDown.clientX = event.clientX;
				onDocumentMouseDown.clientY = event.clientY;
			}
			
			function onDocumentMouseUp(event) {
				
				if (isOpening || paused || record.playing)
					return;
					
				if (event.which === 1 && onDocumentMouseDown.clientX === event.clientX && onDocumentMouseDown.clientY === event.clientY) {
					var point = getIntersectedPoint();
					if (point !== null) {
						robot1.targetPosition.copy(court.localToTarget(point.clone(), robot1.parent));
						targetPoint1.position.copy(court.localToTarget(point.clone(), targetPoint1.parent));
					}
				}
			}
			
			function onDocumentMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
				renderer.domElement.style.cursor = (getIntersectedPoint() === null || record.playing) ? 'default' : 'pointer';
			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				var realDelta = clock.getDelta();
				var delta = realDelta / delay;
				if (delta < 1) {
					if (!paused) {
						if (animated) {
							shuttle.update(delta);
							updateRobot(robot1, delta);
							updateRobot(robot2, delta);
							court.netGroup.checkCollision(shuttle);
							game.checkScore(shuttle, court);
						}
						if (countdown)
							updateCountdown(realDelta);
					}
					updateRobotHUD(robot1);
					updateRobotHUD(robot2);
					scoreboard.update(delta);
					updateTargetPoint(targetPoint1, robot1, delta);
					updateTargetPoint(targetPoint2, robot2, delta);
				}
				$('#pause').toggle(paused);
				$('#start').toggle(isOpening);
				stats.update();
				controls.update();
				requestAnimationFrame(animate);
				render();
			}
			
			function updateCountdown(delta) {
				counter -= delta;
				$('#countdown .counter').text(Math.round(counter));
				if (counter < 0) {
					$('#countdown').hide();
					countdown = false;
					if (typeof countEnding === 'function')
						countEnding();
				}
			}
			
			function updateRobotHUD(robot) {
				robot.spriteHealthPercent.material.uniforms.healthPercent.value = robot.healthPercent;
				robot.spriteHealthPercent.position.copy(robot.position.clone().add(new THREE.Vector3(0, 250, 0)));
				robot.spriteHealthPercent.lookAt(camera.position);
			}
			
			function updateRobot(robot, delta) {
				robot.update(delta);
				updateEyes(robot);
			}
			
			function updateTargetPoint(targetPoint, robot, delta) {
				targetPoint.position.copy(robot.targetPosition);
				targetPoint.update(delta, camera);
			}
			
			function render() {
				raycaster.setFromCamera(mouse, camera);
				intersects = raycaster.intersectObject(touchable);
				
				renderer.setClearColor(0x000000);
				renderer.render(robot1.monitor.scene, robot1.monitor.camera, robot1.monitor.renderTarget);
				renderer.render(robot2.monitor.scene, robot2.monitor.camera, robot2.monitor.renderTarget);
				
				renderer.setClearColor(0x888888);
				renderer.render(scene, camera);
			}
			
			function getRandomImpactType() {
				var random = Math.random();
				if (random < 0.4)
					return 'right';
				else if (random < 0.8)
					return 'left';
				else if (random < 0.9)
					return 'top';
				else
					return 'smash';
			}
			
			function getRandomPosition(area, scale) {
				var center = area.getCenter();
				var size = area.getSize().multiplyScalar(scale);
				var min = center.clone().addScaledVector(size, -0.5);
				return new THREE.Vector3(
					min.x + size.x * Math.random(),
					0,
					min.z + size.z * Math.random());
			}

			function next() {
				
				animated = false;
				
				court.updateMatrixWorld();
				game.initRobot(robot1, court, 'A');
				game.initRobot(robot2, court, 'B');
				
				if (touchableTip)
					scene.remove(touchableTip);
				touchableTip = createTouchableTip();
				scene.add(touchableTip);
				
				robot1.targetPosition.copy(getRandomPosition(robot2.responsibleArea, 0.8));
				robot2.targetPosition.copy(getRandomPosition(robot1.responsibleArea, 0.8));
				
				game.initShuttlecock(shuttle, function () {
					var robot = (game.lastWinner === 'A') ? robot1 : robot2;
					robot.updateMatrixWorld();
					return {
						position: robot.localToTarget(new THREE.Vector3(0, 120, 30), shuttle.parent),
						velocity: robot.localToTarget(new THREE.Vector3(0, 200, 100), shuttle.parent, 'direction'),
					};
				});
				
				game.nextScore();
				
				record.init();
			}
			
			function replay() {
				
				paused = false;
				animated = true;
				
				replay.countEnding = countEnding || replay.countEnding;
				countEnding = null;
				
				record.start(Math.round(replayIndex));
			}
			
			function resume() {
				paused = false;
				if (replay.countEnding) {
					replay.countEnding();
					replay.countEnding = null;
				}
			}
			
			function start() {
				paused = false;
				isOpening = false;
				game.init('B');
				scoreboard.init();
				next();
				startCountdown(function () {
					animated = true;
				}, 3);
			}
			
			function startBackgroundReplay() {
				game.init();
				game.nextScore();
				record.init(getRandomRecordData());
				record.start(0);
				animated = true;
			}
			
			function getRandomRecordData() {
				var names = Object.keys(allRecordData);
				var index = Math.floor(Math.random() * names.length);
				return allRecordData[names[index]];
			}
			
			function startCountdown(ending, second, show) {
				countEnding = ending;
				counter = second;
				countdown = true;
				$('#countdown').toggle(show !== undefined ? show : true);
			}
			
		</script>
	</body>
</html>
