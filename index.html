<!DOCTYPE html>
<html>
	<head>
		<title>Badminton Demo</title>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r77/three.min.js'></script>
		<script src='controls/OrbitControls.js'></script>
		<script src='controls/DeviceOrientationControls.js'></script>
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
			.top {
				position: absolute;
				top: 1em;
				left: 0;
				right: 0;
				text-align: center;
			}
		</style>
		<script src='build/three.badminton.min.js'></script>
	</head>
	<body>
		<div class='top'>
			<div id='score'>[0:0]</div>
			<a href='javascript:toggle()'>Start</a>
			<a href='javascript:next()'>Next</a>
			<a href='javascript:replay()'>Replay</a>
		</div>
		<audio id='impactSound' src='audios/impact.mp3'></audio>
		<script>
			var camera, scene, renderer;
			var control, controls;
			var shuttle, court, game, scoreboard, record;
			var robot1, robot2;
			var targetPoint1, targetPoint2;
			var clock;
			var animated = false;
			var delay = 5;
			var touchable, raycaster, mouse, intersects;

			init();
			animate();

			function init() {

				scene = createScene();

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 20000);
				camera.position.set(-800, 300, 0);
				scene.add(camera);
				
				shuttle = createShuttlecock();
				scene.add(shuttle);
				
				court = createCourt();
				scene.add(court);
				
				var courtArea = court.getArea('All');
				touchable = new THREE.Mesh(
					new THREE.PlaneGeometry(courtArea.max.x - courtArea.min.x, courtArea.max.y - courtArea.min.y),
					new THREE.MeshBasicMaterial({ visible: false }));
				court.add(touchable);
				
				mouse = new THREE.Vector2();
				raycaster = new THREE.Raycaster();
				
				game = new THREE.Badminton.Game(court, shuttle, 2);
				game.onScoreChange = function () {
					$('#score').text('[' + this.score1 + ':' + this.score2 + '] P' + this.lastWinner + ' win.');
				};
				
				clock = new THREE.Clock();
				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);
				
				robot1 = createRobot(court, 'textures/playerBody1.jpeg', 'white', 'blue');
				scene.add(robot1);
				robot1.setCourt(court, 1);
				robot1.shuttle = shuttle;
				robot1.rotation.y = Math.PI / 2;
				robot1.onAfterImpact = function () {
					if (!record.playing) {
						robot2.impactType = getRandomImpactType();
						
						var randomPosition = getRandomPosition(robot1.responsibleArea);
						robot2.targetPosition.copy(randomPosition);
						targetPoint2.position.copy(randomPosition);
					}
				};
				
				robot2 = createRobot(court, 'textures/playerBody2.jpeg', 0xff0000, 0x800000);
				scene.add(robot2);
				robot2.setCourt(court, 2);
				robot2.shuttle = shuttle;
				robot2.rotation.y = -Math.PI / 2;
				robot2.onBeforeUpdate = function() {
					if(this.impactType === 'smash' || this.impactType === 'top') {
						var shuttlePosition = this.shuttle.localToTarget(new THREE.Vector3(0, 0, 0), court);
						if (shuttlePosition.y < 185 && shuttlePosition.x > 0)
							this.impactType = 'right';
					}
				};
				
				targetPoint1 = new THREE.Badminton.TargetPoint(20, 5);
				scene.add(targetPoint1);
				
				targetPoint2 = new THREE.Badminton.TargetPoint(20, 5);
				scene.add(targetPoint2);
				
				scoreboard = new THREE.Badminton.Scoreboard(200, 100, 50, 10);
				scoreboard.rotation.y = -Math.PI / 4;
				scoreboard.position.z = -400;
				scene.add(scoreboard);
				game.scoreboard = scoreboard;
				
				var gui = new dat.GUI();
				
				gui.add(this, 'delay', 1, 30);
				
				control = 'orbit';
				gui.add(this, 'control', ['orbit', 'deviceOrientation']).onChange(onControlChange);
				onControlChange(control);
				
				function onControlChange(value) {
					if (controls)
						controls.dispose();
					if (value === 'orbit') {
						controls = new THREE.OrbitControls(camera, renderer.domElement);
					} else if (value === 'deviceOrientation') {
						controls = new THREE.DeviceOrientationControls(camera);
					}
				}
				
				addRobot(robot1, 'P1 (Player)');
				addRobot(robot2, 'P2 (Computer)');
				
				function addRobot(robot, name) {
					var f = gui.addFolder(name);
					f.add(robot, 'healthPercent', 0, 100).listen();
					f.add(robot, 'impactType', ['left', 'right', 'top', 'smash']).listen();
					f.open();
				}
				
				record = new THREE.Badminton.Record(shuttle, robot1, robot2, game, scoreboard, targetPoint1, targetPoint2);
				robot1.record = record;
				robot2.record = record;
				
				render();
				next();
				
				document.body.appendChild(renderer.domElement);
				document.addEventListener('keypress', onDocumentKeyPress, false);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				window.addEventListener('resize', onWindowResize, false);
			}

			function onDocumentKeyPress(event) {
				switch (event.key) {
					case 'w':
					case 'W':
						robot1.impactType = 'top';
						break;
					case 's':
					case 'S':
						robot1.impactType = 'smash';
						break;
					case 'a':
					case 'A':
						robot1.impactType = 'left';
						break;
					case 'd':
					case 'D':
						robot1.impactType = 'right';
						break;
				}
			}
			
			function createScene() {
				
				var scene = new THREE.Scene();
				
				var textureLoader = new THREE.TextureLoader();
				var skybox = new THREE.Mesh(
					new THREE.BoxGeometry(10000, 10000, 10000, 1, 1, 1),
					new THREE.MultiMaterial([
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox1.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox2.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox3.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox4.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox5.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox6.png'), side: THREE.BackSide }),
					])
				);
				scene.add(skybox);
				
				var ground = new THREE.Mesh(
					new THREE.CylinderGeometry(1500, 400, 300, 64),
					new THREE.MeshLambertMaterial({ color: 0x082908 }));
				ground.position.y = -150.1;
				scene.add(ground);
				
				var wall = new THREE.Mesh(
					new THREE.CylinderGeometry(1500, 1500, 500, 64 ,1, true),
					new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/wall.jpg'), side: THREE.DoubleSide }));
				scene.add(wall);
				
				var light = new THREE.SpotLight(0xffffff, 60, 950, 1, 0.6, 2);
				light.position.y = 700;
				scene.add(light);
				
				return scene;
			}
			
			function createCourt() {
				
				var shortLine = 198;
				var longLineSingle = 670;
				var longLineDouble = 594;
				var sidelineSingle = 259;
				var sidelineDouble = 305;
				var lineWidth = 10;
				
				var netWidth = sidelineDouble * 2;
				var netHeight = 110;
				var netOuterTube = 5
				var netInnerTube = 2
				var netWidthSegments = netWidth / 10;
				var netHeightSegments = netHeight / 10;
				
				var postRadius = 5;
				var postHeight = 155;
				
				var court = new THREE.Badminton.Court(
					new THREE.Badminton.CourtGeometry(shortLine, longLineSingle, longLineDouble, sidelineSingle, sidelineDouble, lineWidth),
					new THREE.MeshBasicMaterial({ color: 'white', side: THREE.DoubleSide }));
				court.rotation.x = -Math.PI / 2;
				
				var netFrame = new THREE.Object3D();
				netFrame.rotation.x = Math.PI / 2;
				court.add(netFrame);
				
				var net = new THREE.Mesh(
					new THREE.Badminton.NetGeometry(netWidth, netHeight, netOuterTube, netInnerTube, netWidthSegments, netHeightSegments),
					new THREE.MeshNormalMaterial({
						side: THREE.DoubleSide
					}));
				net.rotation.y = Math.PI / 2;
				net.position.y = postHeight - netHeight / 2;
				netFrame.add(net);
				
				var post1 = new THREE.Mesh(
					new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 16),
					new THREE.MeshNormalMaterial());
				post1.position.set(0, postHeight / 2, sidelineDouble);
				netFrame.add(post1);
				
				var post2 = post1.clone();
				post2.position.z *= -1;
				netFrame.add(post2);
				
				court.postHeight = postHeight;
				
				return court;
			}
			
			function createShuttlecock() {
				
				var meter2unit = 100;
				var corkRadius = 2.5;
				var skirtRadius = 5;
				var beltHeight = 1;
				var skirtHeight = 6.5;
				var widthSegments = 16;
				var heightSegments = 8;
				var rachisRadius = 0.1;
				var rachisRatio = 3 / 7;
				var featherWidth = 1;
				var featherRatio = 7 / 3;
				var featherAngle = 0.1
				
				var corkMass = 0.005; // mass
				var skirtMass = 0.0001; // mass
				var airDensity = 0.0000011839; // mass * length^-3
				var gravity = new THREE.Vector3(0, -980, 0); // mass * length * time^-2
				
				var shuttlecock = new THREE.Badminton.Shuttlecock(
					new THREE.Badminton.ShuttlecockGeometry(corkRadius, skirtRadius, beltHeight, skirtHeight, widthSegments, heightSegments, rachisRadius, rachisRatio, featherWidth, featherRatio, featherAngle, corkMass / skirtMass
				), new THREE.MultiMaterial([
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'black' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'beige' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' })
				]), corkMass, skirtMass);
				
				shuttlecock.airDensity = airDensity;
				shuttlecock.gravity.copy(gravity);
				
				return shuttlecock;
			}
			
			function createRobot(court, texturePath, topColor, bottomColor) {
				
				var racketWidth = 30;
				var racketHeight = 50;
				var racketTube = 1;
				var racketLineWidth = 1;
				var racketWidthSegments = 6;
				var racketHeightSegments = 10;
				
				var bodyOuterRadius = 25;
				var bodyInnerRadius = 20;
				var bodyHeight = 100;
				
				var headRadius = 25;
				
				var racketMesh = new THREE.Mesh(
					new THREE.Badminton.RacketGeometry(racketWidth, racketHeight, racketTube, racketLineWidth, racketWidthSegments, racketHeightSegments),
					new THREE.MeshNormalMaterial({ side: THREE.DoubleSide }));
				
				var bodyMesh = new THREE.Mesh(
					new THREE.Badminton.HyperbolaGeometry(bodyOuterRadius, bodyInnerRadius, bodyHeight, 16, 16),
					new THREE.MultiMaterial([
						new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(texturePath) }),
						new THREE.MeshBasicMaterial({ color: topColor }),
						new THREE.MeshBasicMaterial({ color: bottomColor }),
					]));
				
				var headFrame = new THREE.Object3D();
				headFrame.position.y = bodyHeight / 2 + headRadius;
				bodyMesh.add(headFrame);
				
				var head = new THREE.Mesh(
					new THREE.SphereGeometry(headRadius, 32, 32, Math.PI * 2 / 3, Math.PI * 5 / 3), 
					new THREE.MeshBasicMaterial({ color: 0x220000, side: THREE.DoubleSide }));
				head.rotation.z = Math.PI / 2;
				headFrame.add(head);
				
				var width = headRadius * 4 / 3;
				var height = headRadius * 3 / 4;
				
				var scene = new THREE.Scene();
				var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, -10, 10);
				var renderTarget = new THREE.WebGLRenderTarget(width, height);
				
				var eyeRight = new THREE.Object3D();
				eyeRight.position.x = -width / 4;
				scene.add(eyeRight);
				
				var eyeLeft = eyeRight.clone();
				eyeLeft.position.x *= -1;
				scene.add(eyeLeft);
				
				var eyebrowRight = new THREE.Mesh(
					new THREE.PlaneGeometry(width / 3, 2),
					new THREE.MeshBasicMaterial({ color: 'white' }));
				eyebrowRight.position.set(0, height / 4, 5);
				eyeRight.add(eyebrowRight);
				
				var eyeballRight = new THREE.Mesh(
					new THREE.CircleGeometry(width / 12, 32),
					new THREE.MeshBasicMaterial({ color: 'white' }));
				eyeballRight.position.set(0, 0, 5);
				eyeRight.add(eyeballRight);
				
				var eyebrowLeft = eyebrowRight.clone();
				eyeLeft.add(eyebrowLeft);
				
				var eyeballLeft = eyeballRight.clone();
				eyeLeft.add(eyeballLeft);
				
				var blackMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
				
				var monitor = new THREE.Mesh(
					new THREE.BoxGeometry(width, height, 2),
					new THREE.MultiMaterial([
						blackMaterial,
						blackMaterial,
						blackMaterial,
						blackMaterial,
						new THREE.Badminton.PixelMaterial({
							map: renderTarget.texture,
							size: new THREE.Vector2(width, height),
							pixelSize: new THREE.Vector2(1, 1)}),
						blackMaterial,
					]));
				monitor.position.z = headRadius * 2 / 3;
				headFrame.add(monitor);
				
				var robot = new THREE.Badminton.Robot(bodyMesh, racketMesh);
				robot.monitor = monitor;
				monitor.eyebrowRight = eyebrowRight;
				monitor.eyebrowLeft = eyebrowLeft;
				monitor.eyeballRight = eyeballRight;
				monitor.eyeballLeft = eyeballLeft;
				monitor.eyeballScope = width / 12;
				monitor.renderTarget = renderTarget;
				monitor.camera = camera;
				monitor.scene = scene;
				
				robot.setImpactAudio(document.getElementById('impactSound'), window.camera, 2000);
				robot.netHeight = court.postHeight;
				robot.netHeightDelta = court.postHeight / 10;
				
				return robot;
			}
			
			function updateEyes() {
				var robots = [robot1, robot2];
				for (var i = 0; i < robots.length; i++) {
					var robot = robots[i];
					var monitor = robot.monitor;
					if (robot.impactType === 'smash') {
						monitor.eyeballLeft.position.x = monitor.eyeballRight.position.x = 0;
						monitor.eyebrowLeft.rotation.z = Math.PI / 8;
						monitor.eyebrowRight.rotation.z = -Math.PI / 8;
					} else {
						var position = shuttle.localToTarget(new THREE.Vector3(0, 0, 0), robot);
						var angle = Math.atan(position.x / Math.max(position.z, 0));
						monitor.eyeballLeft.position.x = monitor.eyeballRight.position.x = THREE.Math.clamp(angle / (Math.PI / 4), -1, 1) * monitor.eyeballScope;
						monitor.eyebrowLeft.rotation.z = 0;
						monitor.eyebrowRight.rotation.z = 0;
					}
				}
			}
			
			function getIntersectedPoint() {
				if (intersects.length > 0) {
					var point = court.worldToLocal(intersects[0].point);
					var area = robot2.parent.localToTarget(robot2.responsibleArea.clone(), court);
					if (point.x >= area.min.x &&
						point.x <= area.max.x &&
						point.y >= area.min.y &&
						point.y <= area.max.y) return point;
				}
				return null;
			}
			
			function onDocumentMouseDown(event) {
				if (event.which === 1) {
					var point = getIntersectedPoint();
					if (point !== null) {
						robot1.targetPosition.copy(court.localToTarget(point.clone(), robot1.parent));
						targetPoint1.position.copy(court.localToTarget(point.clone(), targetPoint1.parent));
					}
				}
			}
			
			function onDocumentMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
				renderer.domElement.style.cursor = (getIntersectedPoint() === null) ? 'default' : 'pointer';
			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				var delta = clock.getDelta() / delay;
				if (animated) {
					shuttle.update(delta);
					robot1.update(delta);
					robot2.update(delta);
					checkNetCollision();
					game.update(delta);
					updateEyes();
				}
				scoreboard.update(delta);
				targetPoint1.update(delta, camera);
				targetPoint2.update(delta, camera);
				controls.update();
				requestAnimationFrame(animate);
				render();
			}
			
			function render() {
				raycaster.setFromCamera(mouse, camera);
				intersects = raycaster.intersectObject(touchable);
				
				renderer.setClearColor(0x000000);
				renderer.render(robot1.monitor.scene, robot1.monitor.camera, robot1.monitor.renderTarget);
				renderer.render(robot2.monitor.scene, robot2.monitor.camera, robot2.monitor.renderTarget);
				
				renderer.setClearColor(0x888888);
				renderer.render(scene, camera);
			}

			function toggle() {
				animated = !animated;
			}
			
			function getRandomImpactType() {
				var random = Math.random();
				if (random < 0.4)
					return 'right';
				else if (random < 0.8)
					return 'left';
				else if (random < 0.9)
					return 'top';
				else
					return 'smash';
			}
			
			function getRandomPosition(area) {
				return new THREE.Vector3(
					area.min.x + (area.max.x - area.min.x) * Math.random(),
					0,
					area.min.z + (area.max.z - area.min.z) * Math.random());
			}
			
			function checkNetCollision() {
				var position = shuttle.localToTarget(new THREE.Vector3(0, 0, 0), scene);
				var lastPosition = shuttle.localToTarget(shuttle.velocity.clone().multiplyScalar(-shuttle.lastDelta), scene);
				var positionDelta = lastPosition.clone().sub(position);
				var mul = -position.x / positionDelta.x;
				var netPosition = position.clone().addScaledVector(positionDelta, mul);
				if ((Math.abs(mul) <= 1 || mul * checkNetCollision.lastUpdateMul < 0) &&
					netPosition.y >= 0 &&
					netPosition.y <= 155 &&
					netPosition.z >= -305 &&
					netPosition.z <= 305) {
					shuttle.state = 'stop-net';
					shuttle.position.copy(scene.localToTarget(netPosition.clone(), shuttle.parent));
				}
				checkNetCollision.lastUpdateMul = mul;
			}

			function next() {
				animated = false;
				
				areaA = court.getArea('SingleFirst' + (game.lastWinnerScore % 2 === 0 ? 'Right' : 'Left') + 'A');
				court.localToTarget(areaA, robot1.parent);
				
				robot1.setResponsibleArea(areaA, true);
				robot1.reset();
				
				var areaB = court.getArea('SingleFirst' + (game.lastWinnerScore % 2 === 0 ? 'Right' : 'Left') + 'B');
				court.localToTarget(areaB, robot2.parent);
				
				robot2.setResponsibleArea(areaB, true);
				robot2.reset();
				
				robot1.impactType = robot2.impactType = 'right';
				
				var randomPosition1 = getRandomPosition(robot2.responsibleArea);
				robot1.targetPosition.copy(randomPosition1);
				targetPoint1.position.copy(randomPosition1);
				
				var randomPosition2 = getRandomPosition(robot1.responsibleArea);
				robot2.targetPosition.copy(randomPosition2);
				targetPoint2.position.copy(randomPosition2);
				
				var area = (game.lastWinner === 1) ?
					court.getArea('SingleFirst' + (game.score1 % 2 == 0 ? 'Right' : 'Left') + 'A') :
					court.getArea('SingleFirst' + (game.score2 % 2 == 0 ? 'Right' : 'Left') + 'B');
				court.localToTarget(area, shuttle.parent);
				shuttle.rotation.set(0, 0, 0);
				shuttle.position.copy(area.min.clone().add(area.max).divideScalar(2).add(new THREE.Vector3(0, 120, 0)));
				shuttle.position.x += 30 * (game.lastWinner === 1 ? 1 : -1);
				shuttle.velocity.set(100 * (game.lastWinner === 1 ? 1 : -1), 200, 0);
				game.nextScore();
				
				$('#score').text('[' + game.score1 + ':' + game.score2 + '] P' + game.lastWinner + ' first.');
				
				record.init();
				checkNetCollision.lastUpdateMul = 0;
			}
			
			function replay() {
				record.play();
			}
		</script>
	</body>
</html>
