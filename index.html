<!DOCTYPE html>
<html>
	<head>
		<title>Badminton Demo</title>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r77/three.min.js'></script>
		<script src='controls/OrbitControls.js'></script>
		<script src='controls/DeviceOrientationControls.js'></script>
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
			.top {
				position: absolute;
				top: 1em;
				left: 0;
				right: 0;
				text-align: center;
			}
		</style>
		<script src='build/three.badminton.min.js'></script>
	</head>
	<body>
		<div class='top'>
			<div id='score'>[0:0]</div>
			<a href='javascript:toggle()'>Start</a>
			<a href='javascript:next()'>Next</a>
			<a href='javascript:replay()'>Replay</a>
		</div>
		<audio id='impactSound' src='audios/impact.mp3'></audio>
		<script>
			var camera, scene, renderer;
			var control, controls;
			var shuttle, court, game, scoreboard, record;
			var robot1, robot2;
			var targetPoint1, targetPoint2;
			var clock;
			var animated = false;
			var delay = 5;
			var touchable, raycaster, mouse, intersects;
			var impactSound;

			init();
			animate();

			function init() {

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 20000);
				camera.position.set(-800, 300, 0);
				scene.add(camera);
				
				var meter2unit = 100;
				
				var corkMass = 0.005;
				var skirtMass = 0.0001;
				shuttle = new THREE.Badminton.Shuttlecock(new THREE.Badminton.ShuttlecockGeometry(
					2.5, 5, 1, 6.5, 16, 8, 0.1, 3 / 7, 1, 7 / 3, 0.1, corkMass / skirtMass
				), new THREE.MultiMaterial([
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'black' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'beige' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' })
				]), corkMass, skirtMass);
				shuttle.meter2unit = meter2unit;
				scene.add(shuttle);
				
				court = new THREE.Badminton.Court(
					new THREE.Badminton.CourtGeometry(198, 670, 594, 259, 305, 10),
					new THREE.MeshBasicMaterial({ color: 'white', side: THREE.DoubleSide }));
				court.rotation.x = -Math.PI / 2;
				scene.add(court);
				
				var netHeight = 110;
				net = new THREE.Mesh(
					new THREE.Badminton.NetGeometry(610, netHeight, 5, 2, 61, netHeight / 10),
					new THREE.MeshNormalMaterial({
						side: THREE.DoubleSide
					}));
				net.rotation.y = Math.PI / 2;
				net.position.y = 155 - netHeight / 2;
				scene.add(net);
				
				var post1 = new THREE.Mesh(
					new THREE.CylinderGeometry(5, 5, 155, 16),
					new THREE.MeshNormalMaterial());
				post1.position.set(0, 77.5, 305);
				scene.add(post1);
				
				var post2 = post1.clone();
				post2.position.z *= -1;
				scene.add(post2);
				
				var courtArea = court.getArea('All');
				touchable = new THREE.Mesh(
					new THREE.PlaneGeometry(courtArea.max.x - courtArea.min.x, courtArea.max.y - courtArea.min.y),
					new THREE.MeshBasicMaterial({ visible: false }));
				court.add(touchable);
				
				mouse = new THREE.Vector2();
				raycaster = new THREE.Raycaster();
				
				game = new THREE.Badminton.Game(court, shuttle, 2);
				game.onScoreChange = function () {
					$('#score').text('[' + this.score1 + ':' + this.score2 + '] P' + this.lastWinner + ' win.');
				};
				
				clock = new THREE.Clock();
				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);
				
				impactSound = document.getElementById('impactSound');
				
				var textureLoader = new THREE.TextureLoader();
				var leftRacketMaterial = new THREE.MeshBasicMaterial({
					map: textureLoader.load('textures/racketLeft.png'),
					transparent: true
				});
				var rightRacketMaterial = new THREE.MeshBasicMaterial({
					map: textureLoader.load('textures/racketRight.png'),
					transparent: true
				});
				var topRacketMaterial = new THREE.MeshBasicMaterial({
					map: textureLoader.load('textures/racketTop.png'),
					transparent: true
				});
				
				robot1 = new THREE.Badminton.Robot();
				scene.add(robot1);
				robot1.waist.material = new THREE.MultiMaterial([
					new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/playerBody1.jpeg') }),
					new THREE.MeshBasicMaterial({ color: 'white' }),
					new THREE.MeshBasicMaterial({ color: 'blue' }),
				]);
				robot1.leftRacket.material = leftRacketMaterial;
				robot1.rightRacket.material = rightRacketMaterial;
				robot1.topRacket.material = topRacketMaterial;
				robot1.setCourt(court, 1);
				robot1.shuttle = shuttle;
				robot1.setImpactAudio(impactSound, camera, 2000);
				robot1.rotation.y = Math.PI / 2;
				robot1.onAfterImpact = function () {
					if (!record.playing) {
						robot2.impactType = getRandomImpactType();
						
						var randomPosition = getRandomPosition(robot1.responsibleArea);
						robot2.targetPosition.copy(randomPosition);
						targetPoint2.position.copy(randomPosition);
					}
				};
				
				robot2 = new THREE.Badminton.Robot();
				scene.add(robot2);
				robot2.waist.material = new THREE.MultiMaterial([
					new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/playerBody2.jpeg') }),
					new THREE.MeshBasicMaterial({ color: 0xff0000 }),
					new THREE.MeshBasicMaterial({ color: 0x800000 }),
				]);
				robot2.leftRacket.material = leftRacketMaterial;
				robot2.rightRacket.material = rightRacketMaterial;
				robot2.topRacket.material = topRacketMaterial;
				robot2.setCourt(court, 2);
				robot2.shuttle = shuttle;
				robot2.setImpactAudio(impactSound, camera, 2000);
				robot2.rotation.y = -Math.PI / 2;
				robot2.onBeforeUpdate = function() {
					if(this.impactType === 'smash' || this.impactType === 'top') {
						var shuttlePosition = this.shuttle.localToTarget(new THREE.Vector3(0, 0, 0), court);
						if (shuttlePosition.y < 185 && shuttlePosition.x > 0)
							this.impactType = 'right';
					}
				};
				
				targetPoint1 = new THREE.Badminton.TargetPoint(20, 5);
				scene.add(targetPoint1);
				
				targetPoint2 = new THREE.Badminton.TargetPoint(20, 5);
				scene.add(targetPoint2);
				
				scoreboard = new THREE.Badminton.Scoreboard(200, 100, 50, 10);
				scoreboard.rotation.y = -Math.PI / 4;
				scoreboard.position.z = -400;
				scene.add(scoreboard);
				game.scoreboard = scoreboard;
				
				var skybox = new THREE.Mesh(
					new THREE.BoxGeometry(10000, 10000, 10000, 1, 1, 1),
					new THREE.MultiMaterial([
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox1.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox2.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox3.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox4.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox5.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox6.png'), side: THREE.BackSide }),
					])
				);
				scene.add(skybox);
				
				var ground = new THREE.Mesh(
					new THREE.CylinderGeometry(1500, 400, 300, 64),
					new THREE.MeshLambertMaterial({ color: 0x082908 }));
				ground.position.y = -150.1;
				scene.add(ground);
				
				var wall = new THREE.Mesh(
					new THREE.CylinderGeometry(1500, 1500, 500, 64 ,1, true),
					new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/wall.jpg'), side: THREE.DoubleSide }));
				scene.add(wall);
				
				var light = new THREE.SpotLight(0xffffff, 60, 950, 1, 0.6, 2);
				light.position.y = 700;
				scene.add(light);
				
				var gui = new dat.GUI();
				
				gui.add(this, 'delay', 1, 30);
				
				control = 'orbit';
				gui.add(this, 'control', ['orbit', 'deviceOrientation']).onChange(onControlChange);
				onControlChange(control);
				
				function onControlChange(value) {
					if (controls)
						controls.dispose();
					if (value === 'orbit') {
						controls = new THREE.OrbitControls(camera, renderer.domElement);
					} else if (value === 'deviceOrientation') {
						controls = new THREE.DeviceOrientationControls(camera);
					}
				}
				
				addRobot(robot1, 'P1 (Player)');
				addRobot(robot2, 'P2 (Computer)');
				
				function addRobot(robot, name) {
					var f = gui.addFolder(name);
					f.add(robot, 'healthPercent', 0, 100).listen();
					f.add(robot, 'impactType', ['left', 'right', 'top', 'smash']).listen();
					f.open();
				}
				
				record = new THREE.Badminton.Record(shuttle, robot1, robot2, game, scoreboard, targetPoint1, targetPoint2);
				robot1.record = record;
				robot2.record = record;
				
				render();
				next();
				
				document.body.appendChild(renderer.domElement);
				document.addEventListener('keypress', onDocumentKeyPress, false);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				window.addEventListener('resize', onWindowResize, false);
			}

			function onDocumentKeyPress(event) {
				switch (event.key) {
					case 'w':
					case 'W':
						robot1.impactType = 'top';
						break;
					case 's':
					case 'S':
						robot1.impactType = 'smash';
						break;
					case 'a':
					case 'A':
						robot1.impactType = 'left';
						break;
					case 'd':
					case 'D':
						robot1.impactType = 'right';
						break;
				}
			}
			
			function getIntersectedPoint() {
				if (intersects.length > 0) {
					var point = court.worldToLocal(intersects[0].point);
					var area = robot2.parent.localToTarget(robot2.responsibleArea.clone(), court);
					if (point.x >= area.min.x &&
						point.x <= area.max.x &&
						point.y >= area.min.y &&
						point.y <= area.max.y) return point;
				}
				return null;
			}
			
			function onDocumentMouseDown(event) {
				if (event.which === 1) {
					var point = getIntersectedPoint();
					if (point !== null) {
						robot1.targetPosition.copy(court.localToTarget(point.clone(), robot1.parent));
						targetPoint1.position.copy(court.localToTarget(point.clone(), targetPoint1.parent));
					}
				}
			}
			
			function onDocumentMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
				renderer.domElement.style.cursor = (getIntersectedPoint() === null) ? 'default' : 'pointer';
			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				var delta = clock.getDelta() / delay;
				if (animated) {
					shuttle.update(delta);
					robot1.update(delta);
					robot2.update(delta);
					checkNetCollision();
					game.update(delta);
				}
				scoreboard.update(delta);
				targetPoint1.update(delta, camera);
				targetPoint2.update(delta, camera);
				controls.update();
				requestAnimationFrame(animate);
				render();
			}
			
			function render() {
				raycaster.setFromCamera(mouse, camera);
				intersects = raycaster.intersectObject(touchable);
				renderer.render(scene, camera);
			}

			function toggle() {
				animated = !animated;
			}
			
			function getRandomImpactType() {
				var random = Math.random();
				if (random < 0.4)
					return 'right';
				else if (random < 0.8)
					return 'left';
				else if (random < 0.9)
					return 'top';
				else
					return 'smash';
			}
			
			function getRandomPosition(area) {
				return new THREE.Vector3(
					area.min.x + (area.max.x - area.min.x) * Math.random(),
					0,
					area.min.z + (area.max.z - area.min.z) * Math.random());
			}
			
			function checkNetCollision() {
				var position = shuttle.localToTarget(new THREE.Vector3(0, 0, 0), scene);
				var lastPosition = shuttle.localToTarget(shuttle.velocity.clone().multiplyScalar(-shuttle.lastDelta), scene);
				var positionDelta = lastPosition.clone().sub(position);
				var mul = -position.x / positionDelta.x;
				var netPosition = position.clone().addScaledVector(positionDelta, mul);
				if ((Math.abs(mul) <= 1 || mul * checkNetCollision.lastUpdateMul < 0) &&
					netPosition.y >= 0 &&
					netPosition.y <= 155 &&
					netPosition.z >= -305 &&
					netPosition.z <= 305) {
					shuttle.state = 'stop-net';
					shuttle.position.copy(scene.localToTarget(netPosition.clone(), shuttle.parent));
				}
				checkNetCollision.lastUpdateMul = mul;
			}

			function next() {
				animated = false;
				
				areaA = court.getArea('SingleFirst' + (game.lastWinnerScore % 2 === 0 ? 'Right' : 'Left') + 'A');
				court.localToTarget(areaA, robot1.parent);
				
				robot1.setResponsibleArea(areaA, true);
				robot1.reset();
				
				var areaB = court.getArea('SingleFirst' + (game.lastWinnerScore % 2 === 0 ? 'Right' : 'Left') + 'B');
				court.localToTarget(areaB, robot2.parent);
				
				robot2.setResponsibleArea(areaB, true);
				robot2.reset();
				
				robot1.impactType = robot2.impactType = 'right';
				
				var randomPosition1 = getRandomPosition(robot2.responsibleArea);
				robot1.targetPosition.copy(randomPosition1);
				targetPoint1.position.copy(randomPosition1);
				
				var randomPosition2 = getRandomPosition(robot1.responsibleArea);
				robot2.targetPosition.copy(randomPosition2);
				targetPoint2.position.copy(randomPosition2);
				
				var area = (game.lastWinner === 1) ?
					court.getArea('SingleFirst' + (game.score1 % 2 == 0 ? 'Right' : 'Left') + 'A') :
					court.getArea('SingleFirst' + (game.score2 % 2 == 0 ? 'Right' : 'Left') + 'B');
				court.localToTarget(area, shuttle.parent);
				shuttle.rotation.set(0, 0, 0);
				shuttle.position.copy(area.min.clone().add(area.max).divideScalar(2).add(new THREE.Vector3(0, 120, 0)));
				shuttle.position.x += 30 * (game.lastWinner === 1 ? 1 : -1);
				shuttle.velocity.set(100 * (game.lastWinner === 1 ? 1 : -1), 200, 0);
				game.nextScore();
				
				$('#score').text('[' + game.score1 + ':' + game.score2 + '] P' + game.lastWinner + ' first.');
				
				record.init();
				checkNetCollision.lastUpdateMul = 0;
			}
			
			function replay() {
				record.play();
			}
		</script>
	</body>
</html>
