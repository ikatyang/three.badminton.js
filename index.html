<!DOCTYPE html>
<html>
	<head>
		<title>Badminton Demo</title>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r82/three.min.js'></script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js'></script>
		<script src='controls/OrbitControls.js'></script>
		<script src='build/three.badminton.min.js'></script>
		<link href='https://fonts.googleapis.com/css?family=Indie+Flower' rel='stylesheet'/>
		<link href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.6/css/bootstrap.min.css' rel='stylesheet'/>
		<script id='hyperbola_vertexShader' type='x-shader/x-vertex'>
			varying vec2 vUv;
			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				vUv = uv;
			}
		</script>
		<script id='hyperbola_fragmentShader' type='x-shader/x-fragment'>
			uniform vec3 color1;
			uniform vec3 color2;
			varying vec2 vUv;
			void main() {
				if ((vUv.x < 0.5 && vUv.y > 0.5) || (vUv.x > 0.5 && vUv.y < 0.5))
					gl_FragColor = vec4(color1, 1.0);
				else
					gl_FragColor = vec4(color2, 1.0);
			}
		</script>
		<script id='circle_vertexShader' type='x-shader/x-vertex'>
			varying vec2 vUv;
			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				vUv = uv;
			}
		</script>
		<script id='circle_fragmentShader' type='x-shader/x-fragment'>
			uniform vec3 color1;
			uniform vec3 color2;
			varying vec2 vUv;
			void main() {
				if (vUv.y > 0.5)
					gl_FragColor = vec4(color1, 1.0);
				else
					gl_FragColor = vec4(color2, 1.0);
			}
		</script>
		<script id='healthPercent_vertexShader' type='x-shader/x-vertex'>
			varying vec2 vUv;
			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				vUv = uv;
			}
		</script>
		<script id='healthPercent_fragmentShader' type='x-shader/x-fragment'>
			uniform float healthPercent;
			varying vec2 vUv;
			void main() {
				if (vUv.x < healthPercent / 100.0)
					gl_FragColor = vec4(1, 0, 0, 0.6);
				else
					gl_FragColor = vec4(1, 1, 1, 0.6);
			}
		</script>
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
			#stats {
				position: fixed;
				left: 0;
				bottom: 0;
			}
			.full-screen {
				position: fixed;
				top: 0;
				left: 0;
				right: 0;
				bottom: 0;
			}
			.overlay {
				opacity: 0.5;
				background: black;
				pointer-events: none;
			}
			.center-screen {
				position: fixed;
			}
			#start h1, #loser h1, #winner h1, #winner .pts, #winner .pts-best {
				color: yellow;
				font-size: 60pt;
				font-family: 'Indie Flower', cursive;
			}
			#winner .pts {
				font-size: 40pt;
			}
			#winner .avgPts {
				font-size: 50pt;
			}
			#winner .pts-best {
				font-size: 30pt;
			}
			#winner .avgPts-best {
				font-size: 40pt;
			}
			#pts .info {
				font-size: 12pt;
			}
			#loser .btn, #winner .btn {
			    max-width: 10em;
				margin: auto;
			}
			#countdown .counter {
				font-family: 'Indie Flower', cursive;
				font-size: 60pt;
				color: yellow;
			}
			
			#start .btn-container {
				margin: 0 25%;
			}
			
			#start .ranking th, #start .ranking td {
				text-align: right;
			}
			
			#assistant .top-left {
				position: absolute;
				top: 1em;
				left: 1em;
			}
			
			#assistant .click-assistant {
				position: absolute;
				bottom: 0;
				right: 0;
				width: 305px;
				height: 335px;
			}
			
			#assistant #pts {
				margin-left: 1em;
				font-size: 20pt;
				font-family: 'Indie Flower', cursive;
				color: yellow;
			}
			
			#assistant .btn-continue {
				margin-left: 0.5em;
			}
			
			.panel {
				min-width: 30%;
			}
		</style>
	</head>
	<body>
		<div id='start' class='heading'>
			<div class='full-screen overlay'></div>
			<div class='center-screen text-center main'>
				<h1>Badminton Soul</h1>
				<div class='btn-container'>
					<a href='javascript:startGame(3, 21)' class='btn btn-default btn-block btn-lg' title='Best of 3 games of 21 points'>Start</a>
					<a href='javascript:openCustomPanel()' class='btn btn-default btn-block btn-lg' title='Best of X games of Y points'>Custom</a>
					<a href='javascript:openRankingPanel()' class='btn btn-default btn-block btn-lg'>Ranking</a>
					<a href='javascript:openAboutPanel()' class='btn btn-default btn-block btn-lg'>About</a>
				</div>
			</div>
			<div class='custom center-screen panel panel-primary' style='display: none;'>
				<div class='panel-heading'>Custom Game</div>
				<div class='panel-body text-center'>
					<p>Best of X game of Y points.</p>
					<div>
						<label>X</label>
						<input type='number' id='customX' placeholder='X' value='3' min='1' step='2'/>
					</div>
					<div>
						<label>Y</label>
						<input type='number' id='customY' placeholder='Y' value='21' min='1' step='1'/>
					</div>
					<a href='javascript:closeCustomPanel()' class='btn btn-default'>Back</a>
					<a href='javascript:startCustomGame()' class='btn btn-default'>Start</a>
				</div>
			</div>
			<div class='ranking center-screen panel panel-primary' style='display: none;'>
				<div class='panel-heading'>Ranking</div>
				<div class='panel-body text-center'>
					<table class='table'>
						<thead>
							<tr>
								<th>#</th>
								<th>pts</th>
							</tr>
						</thead>
						<tbody></tbody>
					</table>
					<a href='javascript:closeRankingPanel()' class='btn btn-default'>Back</a>
				</div>
			</div>
			<div class='about center-screen panel panel-primary' style='display: none;'>
				<div class='panel-heading'>About</div>
				<div class='panel-body text-center'>
					<p>
						This project was designed by
						<a href='//github.com/ikatyang'>@ikatyang</a>,
						<a href='//github.com/welinn'>@welinn</a>,
						<a href='//github.com/l13013312333'>@l13013312333</a>
					</p>
					<a href='javascript:closeAboutPanel()' class='btn btn-default'>Back</a>
				</div>
			</div>
		</div>
		<div id='countdown' class='heading' style='display: none;'>
			<div class='full-screen overlay'></div>
			<div class='center-screen text-center'>
				<span class='counter'></span>
			</div>
		</div>
		<div id='pause' class='heading' style='display: none;'>
			<div class='full-screen overlay'></div>
			<div class='center-screen panel panel-primary'>
				<div class='panel-heading'>Paused</div>
				<div class='panel-body text-center'>
					<a href='javascript:resume()' class='btn btn-default btn-block btn-lg'>Resume</a>
					<a href='javascript:replay()' class='btn btn-default btn-block btn-lg btn-replay' style='display: none;'>Replay</a>
					<a href='javascript:backToHome()' class='btn btn-default btn-block btn-lg'>Back to Home</a>
				</div>
			</div>
		</div>
		<div id='assistant' style='display: none;'>
			<div class='top-left'>
				<a href='javascript:pause()' class='btn btn-default btn-lg'><span class='glyphicon glyphicon-pause'></span> ESC</a>
				<a href='javascript:gameContinue()' class='btn btn-default btn-lg btn-continue' style='display: none;'><span class='glyphicon glyphicon-play'></span> Continue</a>
				<span id='pts'><span class='content'>0</span> pts / <span class='score'>1</span> score <span class='info'></span></span>
			</div>
			<div class='click-assistant' onclick='onAssistantClick(event)'></div>
		</div>
		<div id='loser' class='heading' style='display: none;'>
			<div class='full-screen overlay'></div>
			<div class='center-screen text-center'>
				<h1>You Lose</h1>
				<a href='javascript:backToHome()' class='btn btn-default btn-block btn-lg'>Back</a>
			</div>
		</div>
		<div id='winner' class='heading' style='display: none;'>
			<div class='full-screen overlay'></div>
			<div class='center-screen text-center'>
				<h1>You Win</h1>
				<div class='pts'>points: <span class='avgPts'>0</span></div>
				<div class='pts-best'>best: <span class='avgPts-best'>0</span></div>
				<a href='javascript:backToHome()' class='btn btn-default btn-block btn-lg'>Back</a>
			</div>
		</div>
		<script>
			var camera, scene, renderer, controls, stats, clock;
			var shuttle, court, game, scoreboard, record;
			var robot1, robot2;
			var targetPoint1, targetPoint2;
			var mouse, raycaster;
			var animated = false, paused = false, isOpening = true;
			var countdown = false, counter = 0, countEnding = null, countText;
			var delay = 1, replayIndex = -3;
			var touchable, intersects, touchableTip;
			var readyPositions1, readyPositions2;
			var assistantCamera, replayCamera;
			var playerPts, playerScores;
			var playerLastImpactType;
			var winGame, winScore;
			var ranking;
			var isCustomGame;

			init();
			animate();

			function init() {

				scene = createScene();

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 20000);
				camera.position.set(-800, 300, 0);
				scene.add(camera);
				
				assistantCamera = new THREE.OrthographicCamera(-305, 305, 670, 0, 1, 1000);
				assistantCamera.position.y = 500;
				assistantCamera.rotation.set(-Math.PI / 2, 0, -Math.PI / 2);
				scene.add(assistantCamera);
				
				replayCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 20000);
				scene.add(replayCamera);
				
				clock = new THREE.Clock();
				
				ranking = new THREE.Badminton.Ranking(localStorage);
				ranking.maxCount = 5;
				
				shuttle = createShuttlecock();
				scene.add(shuttle);
				
				court = createCourt();
				scene.add(court);
				
				var courtArea = court.getArea('All');
				touchable = new THREE.Mesh(
					new THREE.PlaneGeometry(courtArea.max.x - courtArea.min.x, courtArea.max.y - courtArea.min.y),
					new THREE.MeshBasicMaterial({ visible: false }));
				court.add(touchable);
				
				mouse = new THREE.Vector2();
				raycaster = new THREE.Raycaster();
				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);
				renderer.setScissorTest(true);
				
				robot1 = createRobot('white', 'blue', shuttle, court);
				robot1.rotation.y = Math.PI / 2;
				robot1.onAfterImpact = function () {
					
					playerLastImpactType = this.impactType;
					
					var randomPosition = getRandomPosition(robot1.responsibleArea, 0.8);
					robot2.targetPosition.copy(randomPosition);
					targetPoint2.position.copy(randomPosition);
					
					if (!isOpening) {
						
						if (this.impactType === 'smash')
							playerPts += 500;
					}
					
					this.setResponsibleArea(court.localToTarget(court.getAreaSingleA(), this.parent));
					
					updateReadyPosition(this, readyPositions1);
				};
				robot1.onBeforeUpdate = function () {
					updateImpactType(this);
				};
				scene.add(robot1);
				
				robot2 = createRobot(0xff0000, 0x800000, shuttle, court);
				robot2.rotation.y = -Math.PI / 2;
				robot2.onAfterImpact = function () {
					
					if (isOpening) {
						
						var randomPosition = getRandomPosition(robot2.responsibleArea, 0.8);
						robot1.targetPosition.copy(randomPosition);
						targetPoint1.position.copy(randomPosition);
						
					} else {
					
						if (readyPositions2.length > 0 && this.position.clone().sub(readyPositions2[readyPositions2.length - 1]).length() > 400)
							playerPts += 500;
					}
					
					this.setResponsibleArea(court.localToTarget(court.getAreaSingleB(), this.parent));
						
					scene.remove(touchableTip);
					touchableTip = createTouchableTip();
					scene.add(touchableTip);
					
					updateReadyPosition(this, readyPositions2);
				};
				robot2.onBeforeUpdate = function () {
					updateImpactType(this);
				};
				scene.add(robot2);
				
				targetPoint1 = createTargetPoint('textures/light1.png', 'blue', 0xffe416);
				scene.add(targetPoint1);
				
				targetPoint2 = createTargetPoint('textures/light2.png', 'red', 0xbadbf3);
				targetPoint2.visible = false;
				scene.add(targetPoint2);
				
				scoreboard = createScoreboard();
				scoreboard.rotation.y = -Math.PI / 4;
				scoreboard.position.z = -400;
				scene.add(scoreboard);
				
				game = new THREE.Badminton.Game('B');
				game.onScoreChange = function () {
					
					if (isOpening)
						return startBackgroundReplay();
					
					if (this.lastWinner === 'A') {
					
						if (readyPositions2.length >= 2 && readyPositions2[readyPositions2.length - 1].clone().sub(readyPositions2[readyPositions2.length - 2]).length() > 400)
							playerPts += 3000;
							
						if (playerLastImpactType === 'smash')
							playerPts += 5000;
						
						var impactCount = Math.floor((robot1.impactCount + 1) / 2);
						if (impactCount === 1)
							playerPts += 10000;
						else if (impactCount === 2)
							playerPts += 5000;
						else if (impactCount === 3)
							playerPts += 2000;
						else if (impactCount <= 5)
							playerPts += 1000;
						else if (impactCount <= 10)
							playerPts += 500;
						else
							playerPts += 100;
							
						scoreboard.setAction(0, this.scoreA, 'next');
					} else {
						scoreboard.setAction(3, this.scoreB, 'next');
					}
					
					$('#pause .btn-replay').show();
					var isWinA = (game.scoreA === winScore);
					var isWinB = (game.scoreB === winScore);
					if (isWinA || isWinB) {
						startCountdown(function () {
							$('#pause .btn-replay').hide();
							$('#assistant .btn-continue').hide();
						
							var winGameA = scoreboard.frontCards[1].number;
							var winGameB = scoreboard.frontCards[2].number;
							
							if (isWinA)
								scoreboard.setAction(1, winGameA + 1, 'next');
							else
								scoreboard.setAction(2, winGameB + 1, 'next');
								
							if (game.scoreA > 0)
								scoreboard.setAction(0, 0, 'prev');
							if (game.scoreB > 0)
								scoreboard.setAction(3, 0, 'prev');
							
							startCountdown(function () {
								if (isWinA && winGameA + 1 === winGame)
									winner();
								else if (isWinB && winGameB + 1 === winGame)
									loser();
								else
									start();
							}, 3, false);
						}, 3, false);
					} else {
						
						startCountdown(function () {
							$('#pause .btn-replay').hide();
							$('#assistant .btn-continue').hide();
							next();
							startCountdown(function () {
								animated = true;
							}, 2, true, function (counter) {
								return counter > 1 ? 'Ready' : 'Go!';
							});
						}, 3, false);
					}
				};
				
				var recordObjects = [shuttle, shuttle.flipFrame];
				(function () {
					for (var i = 0; i < arguments.length; i++) {
					
						var robot = arguments[i];
						recordObjects.push(robot);
						recordObjects.push(robot.body);
						
						for (var j = 0; j < robot.links.length; j++) {
							
							var link = robot.links[j];
							recordObjects.push(link.frameA);
							recordObjects.push(link.frameB);
						}
					}
				})(robot1, robot2);
				record = new THREE.Badminton.Record(recordObjects, 10);
				
				startBackgroundReplay();
				
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				
				createGUI();
				
				stats = new Stats();
				stats.domElement.setAttribute('id', 'stats');
				
				document.body.appendChild(stats.domElement);
				document.body.appendChild(renderer.domElement);
				document.addEventListener('keyup', onDocumentKeyUp, false);
				document.addEventListener('mouseup', onDocumentMouseUp, false);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				window.addEventListener('resize', onWindowResize, false);
			}
			
			function createGUI() {
				
				var gui = new dat.GUI();
				
				gui.add(this, 'delay', 1, 30);
				gui.add(this, 'replayIndex', -10, 10);
				gui.add(targetPoint2, 'visible').name('TargetPoint2');
				
				gui.close();
			}
			
			function onAssistantClick(event) {
				robot1.targetPosition.set(670 - event.offsetY * 2, 0, -305 + event.offsetX * 2);
			}
			
			function onDocumentKeyUp(event) {
				
				if (event.keyCode === 27) {
					
					if (isOpening)
						return;
					
					paused = !paused;
				}
			}
			
			function updateReadyPosition(robot, readyPositions) {
				
				readyPositions.push(robot.position.clone());
				
				var readyPositionSum = new THREE.Vector3(0, 0, 0);
				for (var i = 0; i < readyPositions.length; i++)
					readyPositionSum.add(readyPositions[i]);
				robot.readyPosition = readyPositionSum.divideScalar(readyPositions.length).setY(0);
				
				if (readyPositions.length > 3)
					readyPositions.shift();
			}
			
			function updateImpactType(robot) {
				
				var shuttlePosition = robot.shuttlecock.localToTarget(new THREE.Vector3(0, 0, 0), court);
				if ((robot === robot2 && shuttlePosition.x > 0) || (robot === robot1 && shuttlePosition.x < 0))
					if (shuttlePosition.z > 250)
						robot.impactType = 'smash';
					else if (shuttlePosition.z > 200)
						robot.impactType = 'top';
					else
						robot.impactType = ((shuttlePosition.y > 0 && robot === robot1) || (shuttlePosition.y < 0 && robot === robot2)) ? 'left' : 'right';
				else
					robot.impactType = 'right';
			}
			
			function createScene() {
				
				var scene = new THREE.Scene();
				
				var textureLoader = new THREE.TextureLoader();
				var skybox = new THREE.Mesh(
					new THREE.BoxGeometry(10000, 10000, 10000, 1, 1, 1),
					new THREE.MultiMaterial([
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox1.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox2.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox3.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox4.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox5.png'), side: THREE.BackSide }),
						new THREE.MeshBasicMaterial({ map: textureLoader.load('textures/skybox6.png'), side: THREE.BackSide }),
					])
				);
				scene.add(skybox);
				
				var ground = new THREE.Mesh(
					new THREE.CylinderGeometry(1500, 400, 300, 64),
					new THREE.MeshLambertMaterial({ color: 0x082908 }));
				ground.position.y = -150.1;
				scene.add(ground);
				
				var light = new THREE.SpotLight(0xffffff, 60, 950, 1, 0.6, 2);
				light.position.y = 700;
				scene.add(light);
				
				return scene;
			}
			
			function createTargetPoint(texturePath, arrowColor, iconColor) {
				
				var cylinderRadius = 80 / Math.PI;
				var cylinderHeight = 40;
				
				var arrowWidth = cylinderRadius * 1.5;
				var arrowHeight = cylinderRadius * 1.5;
				
				var targetPoint = new THREE.Object3D();
				
				var cylinder = new THREE.Mesh(
					new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, cylinderHeight, 32, 1, true),
					new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load(texturePath), side: THREE.DoubleSide, transparent: true, depthWrite: false }));
				cylinder.position.y = cylinderHeight / 2;
				targetPoint.add(cylinder);
				
				var arrow = new THREE.Mesh(
					new THREE.Badminton.ArrowGeometry(arrowWidth, arrowHeight, 1, 1),
					new THREE.MeshBasicMaterial({ color: arrowColor }));
				arrow.position.y = cylinderHeight + arrowHeight / 2;
				arrow.rotation.z = Math.PI;
				targetPoint.add(arrow);
				
				var direction = -1;
				var positionY = arrow.position.y;
				var positionDelta = arrowHeight / 5;
				var speed = arrowHeight / 1.5;
				
				targetPoint.update = function (delta, camera) {
					this.lookAt(camera.position.clone().setY(this.localToWorld(new THREE.Vector3(0, 0, 0)).y));
					arrow.position.y += direction * speed * delta;
					if (arrow.position.y > positionY + positionDelta || arrow.position.y < positionY - positionDelta)
						direction *= -1;
				};
				
				var assistantIcon = new THREE.Mesh(
					new THREE.RingGeometry(cylinderRadius - 10, cylinderRadius, 32),
					new THREE.MeshBasicMaterial({ color: iconColor }));
				assistantIcon.position.y = 2;
				assistantIcon.rotation.x = -Math.PI / 2;
				targetPoint.add(assistantIcon);
				
				return targetPoint;
			}
			
			function createCourt() {
				
				var shortLine = 198;
				var longLineSingle = 670;
				var longLineDouble = 594;
				var sidelineSingle = 259;
				var sidelineDouble = 305;
				var lineWidth = 10;
				
				var netWidth = sidelineDouble * 2;
				var netHeight = 110;
				var netOuterTube = 5
				var netInnerTube = 2
				var netWidthSegments = netWidth / 10;
				var netHeightSegments = netHeight / 10;
				
				var postRadius = 5;
				var postHeight = 155;
				
				var court = new THREE.Badminton.Court(
					new THREE.Badminton.CourtGeometry(shortLine, longLineSingle, longLineDouble, sidelineSingle, sidelineDouble, lineWidth),
					new THREE.MeshBasicMaterial({ color: 'white', side: THREE.DoubleSide }));
				court.rotation.x = -Math.PI / 2;
				
				var net = new THREE.Mesh(
					new THREE.Badminton.NetGeometry(netWidth, netHeight, netOuterTube, netInnerTube, netWidthSegments, netHeightSegments),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 0xdddddd }));
				
				var post = new THREE.Mesh(
					new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 16),
					new THREE.MeshBasicMaterial({ color: 'gray' }));
				
				var netGroup = new THREE.Badminton.NetGroup(net, post);
				netGroup.rotation.set(Math.PI / 2, -Math.PI / 2, 0);
				court.add(netGroup);
				
				court.netGroup = netGroup;
				court.postHeight = postHeight;
				
				return court;
			}
			
			function createShuttlecock() {
				
				var corkRadius = 2.5;
				var skirtRadius = 5;
				var beltHeight = 1;
				var skirtHeight = 6.5;
				var widthSegments = 16;
				var heightSegments = 8;
				var rachisRadius = 0.1;
				var rachisRatio = 3 / 7;
				var featherWidth = 1;
				var featherRatio = 7 / 3;
				var featherAngle = 0.1
				
				var corkMass = 0.005; // mass
				var skirtMass = 0.0001; // mass
				var airDensity = 0.0000011839; // mass * length^-3
				var gravity = new THREE.Vector3(0, -980, 0); // mass * length * time^-2
				
				var shuttlecock = new THREE.Badminton.Shuttlecock(
					new THREE.Badminton.ShuttlecockGeometry(corkRadius, skirtRadius, beltHeight, skirtHeight, widthSegments, heightSegments, rachisRadius, rachisRatio, featherWidth, featherRatio, featherAngle, corkMass / skirtMass
				), new THREE.MultiMaterial([
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'black' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'beige' }),
					new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' })
				]), corkMass, skirtMass);
				
				shuttlecock.airDensity = airDensity;
				shuttlecock.gravity.copy(gravity);
				
				var impactAudio = new Audio('audios/impact.mp3');
				var impactAudioChannel = THREE.Badminton.AudioChannel.support() ? new THREE.Badminton.AudioChannel(impactAudio) : null;
				shuttlecock.onAfterImpact = function (velocity, normal, restitutionCoefficient, frictionCoefficient, isGround) {
					
					if (isGround)
						return;
					
					var offset = this.localToTarget(new THREE.Vector3(0, 0, 0), camera);
					var volume = Math.max(Math.pow(1 - offset.length() / 2000, 1.3), 0);
					if (volume > 0) {
						impactAudio.currentTime = 0;
						if (impactAudioChannel) {
							impactAudioChannel.volume = volume;
							impactAudioChannel.setEqualizer(THREE.Math.clamp((offset.x / (window.innerWidth / 2) + 1) / 2, 0, 1));
						} else {
							impactAudio.volume = volume;
						}
						impactAudio.play();
					}
				};
				
				return shuttlecock;
			}
			
			function createRobot(color1, color2, shuttlecock, court) {
				
				var racketWidth = 30;
				var racketHeight = 50;
				var racketTube = 1;
				var racketLineWidth = 1;
				var racketWidthSegments = 6;
				var racketHeightSegments = 10;
				
				var bodyOuterRadius = 25;
				var bodyInnerRadius = 20;
				var bodyHeight = 100;
				
				var headRadius = 25;
				
				var racketMesh = new THREE.Mesh(
					new THREE.Badminton.RacketGeometry(racketWidth, racketHeight, racketTube, racketLineWidth, racketWidthSegments, racketHeightSegments),
					new THREE.MultiMaterial([
						new THREE.MeshLambertMaterial({ color: 'orange' }),
						new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, color: 'white' }),
					]));
				
				var bodyMesh = new THREE.Mesh(
					new THREE.Badminton.HyperbolaGeometry(bodyOuterRadius, bodyInnerRadius, bodyHeight, 16, 16),
					new THREE.MultiMaterial([
						new THREE.ShaderMaterial({
							uniforms: {
								color1: { value: new THREE.Color(color1) },
								color2: { value: new THREE.Color(color2) },
							},
							vertexShader: document.getElementById('hyperbola_vertexShader').textContent,
							fragmentShader: document.getElementById('hyperbola_fragmentShader').textContent,
						}),
						new THREE.ShaderMaterial({
							uniforms: {
								color1: { value: new THREE.Color(color1) },
								color2: { value: new THREE.Color(color2) },
							},
							vertexShader: document.getElementById('circle_vertexShader').textContent,
							fragmentShader: document.getElementById('circle_fragmentShader').textContent,
						}),new THREE.ShaderMaterial({
							uniforms: {
								color1: { value: new THREE.Color(color1) },
								color2: { value: new THREE.Color(color2) },
							},
							vertexShader: document.getElementById('circle_vertexShader').textContent,
							fragmentShader: document.getElementById('circle_fragmentShader').textContent,
						}),
					]));
				
				var headFrame = new THREE.Object3D();
				headFrame.position.y = bodyHeight / 2 + headRadius;
				bodyMesh.add(headFrame);
				
				var head = new THREE.Mesh(
					new THREE.SphereGeometry(headRadius, 32, 32, Math.PI * 2 / 3, Math.PI * 5 / 3), 
					new THREE.MeshBasicMaterial({ color: 0x220000, side: THREE.DoubleSide }));
				head.rotation.z = Math.PI / 2;
				headFrame.add(head);
				
				var width = headRadius * 4 / 3;
				var height = headRadius * 3 / 4;
				
				var scene = new THREE.Scene();
				var renderTarget = new THREE.WebGLRenderTarget(width, height);
				
				var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, -10, 10);
				scene.add(camera);
				
				var eyeRight = new THREE.Object3D();
				eyeRight.position.x = -width / 4;
				scene.add(eyeRight);
				
				var eyeLeft = eyeRight.clone();
				eyeLeft.position.x *= -1;
				scene.add(eyeLeft);
				
				var eyebrowRight = new THREE.Mesh(
					new THREE.PlaneGeometry(width / 3, 2),
					new THREE.MeshBasicMaterial({ color: 'white' }));
				eyebrowRight.position.set(0, height / 4, 5);
				eyeRight.add(eyebrowRight);
				
				var eyeballRight = new THREE.Mesh(
					new THREE.CircleGeometry(width / 12, 32),
					new THREE.MeshBasicMaterial({ color: 'white' }));
				eyeballRight.position.set(0, 0, 5);
				eyeRight.add(eyeballRight);
				
				var eyebrowLeft = eyebrowRight.clone();
				eyeLeft.add(eyebrowLeft);
				
				var eyeballLeft = eyeballRight.clone();
				eyeLeft.add(eyeballLeft);
				
				var blackMaterial = new THREE.MeshBasicMaterial({ color: 'black' });
				
				var monitor = new THREE.Mesh(
					new THREE.BoxGeometry(width, height, 2),
					new THREE.MultiMaterial([
						blackMaterial,
						blackMaterial,
						blackMaterial,
						blackMaterial,
						new THREE.Badminton.PixelMaterial({
							map: renderTarget.texture,
							size: new THREE.Vector2(width, height),
							pixelSize: new THREE.Vector2(1, 1)}),
						blackMaterial,
					]));
				monitor.position.z = headRadius * 2 / 3;
				headFrame.add(monitor);
				
				var robot = new THREE.Badminton.Robot(bodyMesh, racketMesh);
				robot.monitor = monitor;
				monitor.eyebrowRight = eyebrowRight;
				monitor.eyebrowLeft = eyebrowLeft;
				monitor.eyeballRight = eyeballRight;
				monitor.eyeballLeft = eyeballLeft;
				monitor.eyeballScope = width / 12;
				monitor.renderTarget = renderTarget;
				monitor.camera = camera;
				monitor.scene = scene;
				
				robot.shuttlecock = shuttlecock;
				
				robot.netHeight = court.postHeight;
				robot.netHeightDelta = court.postHeight / 10;
				
				window.scene.add(robot.spriteHealthPercent = new THREE.Mesh(
					new THREE.PlaneGeometry(100, 20),
					new THREE.ShaderMaterial({
						transparent: true,
						uniforms: {
							healthPercent: { value: 100 },
						},
						vertexShader: document.getElementById('healthPercent_vertexShader').textContent,
						fragmentShader: document.getElementById('healthPercent_fragmentShader').textContent,
					})));
				
				return robot;
			}
			
			function updateEyes(robot) {
				var monitor = robot.monitor;
				if (robot.impactType === 'smash') {
					monitor.eyeballLeft.position.x = monitor.eyeballRight.position.x = 0;
					monitor.eyebrowLeft.rotation.z = Math.PI / 8;
					monitor.eyebrowRight.rotation.z = -Math.PI / 8;
				} else {
					var position = shuttle.localToTarget(new THREE.Vector3(0, 0, 0), robot);
					var angle = Math.atan(position.x / Math.max(position.z, 0)) || 0;
					monitor.eyeballLeft.position.x = monitor.eyeballRight.position.x = THREE.Math.clamp(angle / (Math.PI / 4), -1, 1) * monitor.eyeballScope;
					monitor.eyebrowLeft.rotation.z = 0;
					monitor.eyebrowRight.rotation.z = 0;
				}
			}
			
			function createScoreboard() {
				var scoreboard = new THREE.Badminton.Scoreboard(
					new THREE.Badminton.ScoreboardGeometry(200, 100, 50),
					new THREE.MeshLambertMaterial({
						color: 0x0066ff,
						side: THREE.DoubleSide,
					}));
				
				scoreboard.addCard(50, 80, new THREE.Vector2(-65, 10), { side: THREE.DoubleSide, numberColor: 'red' });
				scoreboard.addCard(25, 40, new THREE.Vector2(-17.5, 10), { side: THREE.DoubleSide, numberColor: 'red' });
				scoreboard.addCard(25, 40, new THREE.Vector2(17.5, 10), { side: THREE.DoubleSide, numberColor: 'black' });
				scoreboard.addCard(50, 80, new THREE.Vector2(65, 10), { side: THREE.DoubleSide, numberColor: 'black' });
				
				var ring = new THREE.Mesh(
					new THREE.TorusGeometry(12, 1, 16, 16),
					new THREE.MeshBasicMaterial({ color: 'black' }));
				ring.rotation.y = Math.PI / 2;
				scoreboard.addRings(ring, [-80, -65, -50, -17.5, 17.5, 50, 65, 80]);
				
				return scoreboard;
			}
			
			function createTouchableTip() {
				
				var length = 5;
				
				var box = robot2.parent.localToTarget(robot2.responsibleArea.clone(), scene);
				
				var size = box.getSize();
				var center = box.getCenter();
				
				var touchableTip = new THREE.Object3D();
				touchableTip.position.y = 1;
				
				var material = new THREE.MeshBasicMaterial({ color: 'blue', side: THREE.DoubleSide });
				
				var left = new THREE.Mesh(new THREE.PlaneGeometry(length, size.z), material);
				left.rotation.x = -Math.PI / 2;
				left.position.copy(center).add(new THREE.Vector3(-size.x / 2 + length / 2, 0, 0));
				touchableTip.add(left);
				
				var right = left.clone();
				right.position.copy(center).add(new THREE.Vector3(size.x / 2 - length / 2, 0, 0));
				touchableTip.add(right);
				
				var top = new THREE.Mesh(new THREE.PlaneGeometry(size.x, length), material);
				top.rotation.x = -Math.PI / 2;
				top.position.copy(center).add(new THREE.Vector3(0, 0, -size.z / 2 + length / 2));
				touchableTip.add(top);
				
				var bottom = top.clone();
				bottom.position.copy(center).add(new THREE.Vector3(0, 0, size.z / 2 - length / 2));
				touchableTip.add(bottom);
				
				return touchableTip;
			}
			
			function getIntersectedPoint() {
				if (intersects.length > 0) {
					var point = court.worldToLocal(intersects[0].point);
					var area = robot2.parent.localToTarget(robot2.responsibleArea.clone(), court);
					if (point.x >= area.min.x &&
						point.x <= area.max.x &&
						point.y >= area.min.y &&
						point.y <= area.max.y) return point.setZ(0);
				}
				return null;
			}
			
			function onDocumentMouseDown(event) {
				
				onDocumentMouseDown.clientX = event.clientX;
				onDocumentMouseDown.clientY = event.clientY;
			}
			
			function onDocumentMouseUp(event) {
				
				if (isOpening || paused)
					return;
					
				if (event.which === 1 && onDocumentMouseDown.clientX === event.clientX && onDocumentMouseDown.clientY === event.clientY) {
					var point = getIntersectedPoint();
					if (point !== null) {
						robot1.targetPosition.copy(court.localToTarget(point.clone(), robot1.parent));
						targetPoint1.position.copy(court.localToTarget(point.clone(), targetPoint1.parent));
					}
				}
			}
			
			function onDocumentMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
				renderer.domElement.style.cursor = (getIntersectedPoint() === null || record.playing) ? 'default' : 'pointer';
			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				var realDelta = clock.getDelta();
				var delta = realDelta / delay;
				if (delta < 1) {
					if (!paused) {
						if (animated) {
							if (!record.playing) {
								shuttle.update(delta);
								updateRobot(robot1, delta);
								updateRobot(robot2, delta);
								court.netGroup.checkCollision(shuttle);
								game.checkScore(shuttle, court);
								if (!(shuttle.hasState('toppled') || shuttle.hasState('hung')))
									record.record(delta);
							} else {
								record.update(delta);
							}
						}
						if (countdown)
							updateCountdown(realDelta);
					}
					updateRobotHUD(robot1);
					updateRobotHUD(robot2);
					scoreboard.update(delta);
					updateTargetPoint(targetPoint1, robot1, delta);
					updateTargetPoint(targetPoint2, robot2, delta);
				}
				$('#pts .content').text(playerPts && formatNumber(playerPts));
				$('#pts .score').text(playerScores);
				$('#pts .info').text(!isCustomGame ? '' : '( bo' + (winGame * 2 - 1) + ' of ' + winScore + ' )');
				$('#assistant').toggle(!(isOpening || paused));
				$('#pause').toggle(paused);
				$('#start').toggle(isOpening);
				$('.center-screen').each(function () {
					var $this = $(this);
					var width = $this.width();
					var height = $this.height();
					var vertical = (window.innerHeight - height) / 2;
					var horizontal = (window.innerWidth - width) / 2;
					$this.css('top', vertical + 'px');
					$this.css('left', horizontal + 'px');
				});
				stats.update();
				controls.update();
				requestAnimationFrame(animate);
				render();
			}
			
			function updateCountdown(delta) {
				counter -= delta;
				$('#countdown .counter').text(countText(counter));
				if (counter < 0) {
					$('#countdown').hide();
					countdown = false;
					if (typeof countEnding === 'function')
						countEnding();
				}
			}
			
			function updateRobotHUD(robot) {
				robot.spriteHealthPercent.material.uniforms.healthPercent.value = robot.healthPercent;
				robot.spriteHealthPercent.position.copy(robot.position.clone().add(new THREE.Vector3(0, 250, 0)));
				robot.spriteHealthPercent.lookAt(camera.position);
			}
			
			function updateRobot(robot, delta) {
				robot.update(delta);
				updateEyes(robot);
			}
			
			function updateTargetPoint(targetPoint, robot, delta) {
				targetPoint.position.copy(robot.targetPosition);
				targetPoint.update(delta, camera);
			}
			
			function render() {
				raycaster.setFromCamera(mouse, camera);
				intersects = raycaster.intersectObject(touchable);
				
				renderer.setScissor(0, 0, window.innerWidth, window.innerHeight);
				renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
				
				renderer.setClearColor(0x000000);
				renderer.render(robot1.monitor.scene, robot1.monitor.camera, robot1.monitor.renderTarget);
				renderer.render(robot2.monitor.scene, robot2.monitor.camera, robot2.monitor.renderTarget);
				
				setHeelthPercentVisible(true);
				
				renderer.setClearColor(0x888888);
				renderer.render(scene, camera);
				
				if (!(isOpening || paused)) {
				
					setHeelthPercentVisible(false);
						
					if (record.playing) {
						
						var center = shuttle.geometry.boundingSphere.center;
						var shuttlePosition = shuttle.mesh.localToWorld(center.clone());
						var cameraPosition = shuttle.mesh.localToWorld(center.clone().add(new THREE.Vector3(-50, 0, 0)));
						replayCamera.position.copy(cameraPosition);
						replayCamera.lookAt(shuttlePosition);
						
						renderer.setScissor(window.innerWidth - 300, 0, 300, 300);
						renderer.setViewport(window.innerWidth - 300, 0, 300, 300);
						renderer.render(scene, replayCamera);
						
					} else {
						
						renderer.setScissor(window.innerWidth - 305, 0, 305, 335);
						renderer.setViewport(window.innerWidth - 305, 0, 305, 335);
						renderer.render(scene, assistantCamera);
					}
				}
			}
			
			function setHeelthPercentVisible(visible) {
				robot1.spriteHealthPercent.visible = visible;
				robot2.spriteHealthPercent.visible = visible;
			}
			
			function getRandomImpactType() {
				var random = Math.random();
				if (random < 0.4)
					return 'right';
				else if (random < 0.8)
					return 'left';
				else if (random < 0.9)
					return 'top';
				else
					return 'smash';
			}
			
			function getRandomPosition(area, scale) {
				var center = area.getCenter();
				var size = area.getSize().multiplyScalar(scale);
				var min = center.clone().addScaledVector(size, -0.5);
				return new THREE.Vector3(
					min.x + size.x * Math.random(),
					0,
					min.z + size.z * Math.random());
			}

			function next() {
				
				animated = false;
				
				court.updateMatrixWorld();
				
				var healthPercent1 = robot1.healthPercent;
				var healthPercent2 = robot2.healthPercent;
				
				game.initRobot(robot1, court, 'A');
				game.initRobot(robot2, court, 'B');
				
				robot1.healthPercent = healthPercent1;
				robot2.healthPercent = healthPercent2;
				
				robot1.readyPosition = robot2.readyPosition = null;
				readyPositions1 = [];
				readyPositions2 = [];
				
				if (touchableTip)
					scene.remove(touchableTip);
				touchableTip = createTouchableTip();
				scene.add(touchableTip);
				
				robot1.targetPosition.copy(getRandomPosition(robot2.responsibleArea, 0.8));
				robot2.targetPosition.copy(getRandomPosition(robot1.responsibleArea, 0.8));
				
				game.initShuttlecock(shuttle, function () {
					var robot = (game.lastWinner === 'A') ? robot1 : robot2;
					robot.updateMatrixWorld();
					return {
						position: robot.localToTarget(new THREE.Vector3(0, 120, 30), shuttle.parent),
						velocity: robot.localToTarget(new THREE.Vector3(0, 200, 100), shuttle.parent, 'direction'),
					};
				});
				
				game.nextScore();
				playerScores++;
				
				record.init();
			}
			
			function winner() {
				var rank = Math.floor(playerPts / playerScores);
				
				$('#winner .avgPts').text(formatNumber(rank));
				$('#winner .avgPts-best').text(formatNumber(ranking.getBestRank()));
				$('#winner').show();
				
				$('#winner .pts-best').toggle(!isCustomGame);
				if (!isCustomGame)
					ranking.addRank(rank);
			}
			
			function loser() {
				$('#loser').show();
			}
			
			function replay() {
				
				replay.hp1 = replay.hp1 || robot1.healthPercent;
				replay.hp2 = replay.hp2 || robot2.healthPercent;
				
				$('#assistant .btn-continue').show();
				
				paused = false;
				animated = true;
				
				replay.countEnding = countEnding || replay.countEnding;
				countEnding = null;
				
				record.start(Math.round(replayIndex));
			}
			
			function pause() {
				paused = true;
			}
			
			function resume() {
				paused = false;
			}
			
			function gameContinue() {
				
				robot1.healthPercent = replay.hp1;
				robot2.healthPercent = replay.hp2;
				
				replay.hp1 = replay.hp2 = null;
				
				replay.countEnding();
				replay.countEnding = null;
			}
			
			function formatNumber(number) {
				return number.toString().replace(/\B(?=([0-9]{3})+(?![0-9]))/g, ',');
			}
			
			function openRankingPanel() {
				var $tbody = $('#start .panel.ranking tbody').empty();
				
				var ranks = ranking.getRanks();
				for (var i = 0; i < ranks.length; i++)
					$tbody.append('<tr><td>' + (i + 1) + '</td><td>' + formatNumber(ranks[i]) + '</td></tr>');
				
				$('#start .main').hide();
				$('#start .panel.ranking').show();
			}
			
			function closeRankingPanel() {
				$('#start .main').show();
				$('#start .panel.ranking').hide();
			}
			
			function startCustomGame() {
				closeCustomPanel();
				var customX = Number($('#customX').val());
				var customY = Number($('#customY').val());
				startGame(customX, customY);
				isCustomGame = true;
			}
			
			function openCustomPanel() {
				$('#start .main').hide();
				$('#start .panel.custom').show();
			}
			
			function closeCustomPanel() {
				$('#start .main').show();
				$('#start .panel.custom').hide();
			}
			
			function openAboutPanel() {
				$('#start .main').hide();
				$('#start .panel.about').show();
			}
			
			function closeAboutPanel() {
				$('#start .main').show();
				$('#start .panel.about').hide();
			}
			
			function startGame(customX, customY) {
				playerPts = 0;
				playerScores = 0;
				window.winGame = Math.floor((customX + 1) / 2);
				window.winScore = customY;
				scoreboard.init();
				start();
				isCustomGame = false;
			}
			
			function start() {
			
				robot1.healthPercent = robot2.healthPercent = 100;
				replay.hp1 = replay.hp2 = null;
				
				playerLastImpactType = null;
				paused = false;
				isOpening = false;
				game.init('B');
				next();
				startCountdown(function () {
					animated = true;
				}, 2, true, function (counter) {
					return counter > 1 ? 'Ready' : 'Go!';
				});
			}
			
			function startBackgroundReplay() {
				game.init(Math.random() > 0.5 ? 'A' : 'B');
				next();
				robot1.healthPercent = robot2.healthPercent = 100;
				animated = true;
			}
			
			function startCountdown(ending, second, show, formatter) {
				countEnding = ending;
				counter = second;
				countdown = true;
				countText = formatter || Math.round;
				$('#countdown').toggle(show !== undefined ? show : true);
			}
			
			function backToHome() {
				isOpening = true;
				paused = false;
				countdown = false;
				$('#countdown, #winner, #loser').hide();
				startBackgroundReplay();
			}
			
		</script>
	</body>
</html>
